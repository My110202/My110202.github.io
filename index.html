<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="坚持学习" />
   
  <meta name="description" content="记录你我" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Mayue
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="Mayue" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover3.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Mayue</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
        <img
          src="/images/ayer.svg"
          class="cover-logo"
          alt="Mayue"
        />
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article
  id="post-git命令"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/09/git%E5%91%BD%E4%BB%A4/"
    >git使用记录</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/06/09/git%E5%91%BD%E4%BB%A4/" class="article-date">
  <time datetime="2020-06-08T16:00:00.000Z" itemprop="datePublished">2020-06-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/web%E5%89%8D%E7%AB%AF/">web前端</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="git-bash-unix与linux风格的命令行-使用最多"><a href="#git-bash-unix与linux风格的命令行-使用最多" class="headerlink" title="git bash: unix与linux风格的命令行(使用最多)"></a>git bash: unix与linux风格的命令行(使用最多)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cd: 切换目录</span><br><span class="line">cd ~	回到home(最顶层目录)</span><br><span class="line">cd 		直接cd回到默认目录</span><br><span class="line">cd ..	回到上一级目录</span><br><span class="line">pwd		查看当前所在目录路径</span><br><span class="line">ls(ll)	都是列出当前目录中的所有文件,区别是ll列出的内容更为详细(包括时间)</span><br><span class="line">mkdir hellow	新建一个文件夹(hello文件夹)</span><br><span class="line">touch index.js	新建一个文件(index.js)</span><br><span class="line">rm -r	删除一个文件夹(rm -r hello 删除hello文件夹)</span><br><span class="line">mv	移动文件</span><br><span class="line">mv test hello	移动test文件到hello文件夹</span><br><span class="line">reset	重新初始化终端/清屏</span><br><span class="line">clear	清屏</span><br><span class="line">history		查看历史动作</span><br><span class="line">help	帮助</span><br><span class="line">exit	退出命令框</span><br><span class="line">cat hello	显示hello文件内容</span><br></pre></td></tr></table></figure>

<h3 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -l	查看现在的git环境的详细配置</span><br></pre></td></tr></table></figure>

<h3 id="git工作流程"><a href="#git工作流程" class="headerlink" title="git工作流程"></a>git工作流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.在工作目录中添加,修改文件</span><br><span class="line">2.将需要进行版本管理的文件放入暂存区</span><br><span class="line">3.将暂存区的文件提交到git仓库</span><br><span class="line">因此,git管理的文件由三种状态:已修改(modified),已暂存(staged),已提交(committed)</span><br><span class="line">step1:git add	添加到暂存区</span><br><span class="line">step2:git commit	提交到仓库</span><br><span class="line">step3:git push		推送到远程仓库</span><br></pre></td></tr></table></figure>

<h3 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">四种状态</span><br><span class="line">untracked: 未跟踪,不被git管理的文件,通过git add 文件名 命令,状态变为staged</span><br><span class="line">unmodify: 未修改,被git管理,此时文件的内容与版本库中的文件内容一致,这种类型的文件由两种去除,如果被修改,状态		就变为modified,如果使用git rm &#39;文件名&#39; 移出版本库,状态变成untraked</span><br><span class="line">modified: 修改过的,有两个去向,使用git add &#39;文件名&#39; 将文件暂存起来,另一个是使用git checkout 则丢弃修改,状		态变为unmodified</span><br><span class="line">staged: 暂存状态,有两个去向,使用git commit -m&quot;&quot;提交到仓库,此时库中的文件和本地的一致,文件状态变为			unmodified,另一个使用git reset HEAD &#39;文件名&#39; 取消暂存,文件状态变为unmodified</span><br><span class="line">git status	查看所有文件状态</span><br><span class="line">git status hello	查看hello文件状态</span><br></pre></td></tr></table></figure>

<h3 id="git-取消文件跟踪"><a href="#git-取消文件跟踪" class="headerlink" title="git 取消文件跟踪"></a>git 取消文件跟踪</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对某个文件取消跟踪</span><br><span class="line">git rm --cached hello.vue	取消hello.vue的跟踪,本地hello.vue这个文件还有</span><br><span class="line">git rm --f hello.vue	取消hello.vue的跟踪,并在本地把hello.vue这个文件删除</span><br><span class="line">对所有文件都取消跟踪</span><br><span class="line">git rm -r --cached .	取消所有文件的跟踪,但是本地还有这些文件</span><br><span class="line">git rm -r --f .		取消所有文件的跟踪,并且删除了本地文件</span><br></pre></td></tr></table></figure>

<h3 id="git-丢弃已修改的文件"><a href="#git-丢弃已修改的文件" class="headerlink" title="git 丢弃已修改的文件"></a>git 丢弃已修改的文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">丢弃某个文件的修改</span><br><span class="line">git checkout -- hello.vue	丢弃hello.vue的修改</span><br><span class="line">丢弃所有文件的修改</span><br><span class="line">git checkout .		</span><br><span class="line">本地新增了一些文件,没有git add 到暂存区,想放弃修改</span><br><span class="line">rm hello.js		删除hello.js文件</span><br></pre></td></tr></table></figure>

<h3 id="撤销git-add-撤销已添加至暂存区的文件"><a href="#撤销git-add-撤销已添加至暂存区的文件" class="headerlink" title="撤销git add  (撤销已添加至暂存区的文件)"></a>撤销git add  (撤销已添加至暂存区的文件)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD hello.js		撤销已经add到暂存区的hello.js</span><br><span class="line">git reset HEAD .	撤销add到暂存区的所有文件</span><br></pre></td></tr></table></figure>



<h3 id="git-add-添加文件与目录"><a href="#git-add-添加文件与目录" class="headerlink" title="git add 添加文件与目录"></a>git add 添加文件与目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git add .	添加当前目录的所有文件到暂存区</span><br><span class="line">git add --all	添加所有的文件</span><br><span class="line">以下是添加指定文件夹或文件到暂存区</span><br><span class="line">git add hello	添加hello文件夹(包括子目录)到暂存区(要先进入到hello文件夹的父文件夹)</span><br><span class="line">git add test.js		添加test.js文件到暂存区(要先进入到hello文件夹的父文件夹)</span><br><span class="line">git reset HEAD test.js	撤销刚刚的git add操作</span><br></pre></td></tr></table></figure>

<h3 id="在本地新建分支首次推送到远程-在本地新建分支之后要先推送到远程"><a href="#在本地新建分支首次推送到远程-在本地新建分支之后要先推送到远程" class="headerlink" title="在本地新建分支首次推送到远程(在本地新建分支之后要先推送到远程)"></a>在本地新建分支首次推送到远程(在本地新建分支之后要先推送到远程)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当在本地新建一个fb-dev分支,git push时会提示 git push --set-upstream origin fb-dev</span><br><span class="line">出现这个提示的原因: 因为在远程没有与本地fb-dev相对应的分支</span><br><span class="line">所以第一次git push时会提示</span><br><span class="line">使用git push --set-upstream origin fb-dev这个命令推送分支后,以后再推送fb-dev分支的时候就可以直接使用git push了</span><br><span class="line">git push --set-upstream origin fb-dev 的缩写形式为 git push -u origin fb-dev</span><br></pre></td></tr></table></figure>

<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git branch devmy 创建一个分支(devmy分支)</span><br><span class="line">git branch -d devmy 删除分支(devmy)</span><br><span class="line">git push origin --<span class="keyword">delete</span> devmy 删除远程分支devmy</span><br><span class="line">git checkout devmy 切换分支(切换到devmy分支)</span><br><span class="line">git branch 查看当前所在分支</span><br><span class="line">git branch -a 查看所有分支</span><br><span class="line"></span><br><span class="line">git checkout -b fb-form origin/fb-form	把远程fb-form分支拉取到本地并直接切换到本地fb-form分支</span><br><span class="line">git checkout -b fb-workorder origin		从远程master拉取一个新的分支</span><br></pre></td></tr></table></figure>



<h3 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard  HEAD^		回退到上一版本</span><br></pre></td></tr></table></figure>

<h3 id="git-stash-用法"><a href="#git-stash-用法" class="headerlink" title="git stash 用法"></a>git stash 用法</h3><ul>
<li>git stash 命令将当前的工作状态保存到git 栈,在需要的时候再恢复</li>
</ul>
<h4 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">保存当前的工作区与暂存区的状态，把当前的工作隐藏起来，等以后需要的时候再恢复,git stash 这个命令可以多次使用，每次使用都会新加一个stash@&#123;num&#125;，num是编号</span><br></pre></td></tr></table></figure>

<h4 id="git-stash-save"><a href="#git-stash-save" class="headerlink" title="git stash save"></a>git stash save</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">作用同git stash, 区别是可以加注释</span><br><span class="line">如:git stash save &quot;your stash message&quot;</span><br></pre></td></tr></table></figure>





<h4 id="git-stash-pop"><a href="#git-stash-pop" class="headerlink" title="git stash pop"></a>git stash pop</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">默认恢复git stash栈中最新的一个stash@&#123;num&#125;,建议在git栈中只有一条的时候时候,以免混乱</span><br></pre></td></tr></table></figure>

<h4 id="git-stash-list"><a href="#git-stash-list" class="headerlink" title="git stash list"></a>git stash list</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查看所有被隐藏的文件列表</span><br></pre></td></tr></table></figure>

<h4 id="git-stash-apply"><a href="#git-stash-apply" class="headerlink" title="git stash apply"></a>git stash apply</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">恢复被隐藏的文件, 但是在git栈中的这个不删除,用法: git stash apply@&#123;0&#125;</span><br></pre></td></tr></table></figure>

<h4 id="git-stash-drop"><a href="#git-stash-drop" class="headerlink" title="git stash drop"></a>git stash drop</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">删除指定的一个进度,默认删除最新的进度,用法:git stash drop stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>

<h4 id="git-stash-clear"><a href="#git-stash-clear" class="headerlink" title="git stash clear"></a>git stash clear</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">删除所有存储的进度</span><br></pre></td></tr></table></figure>

<h4 id="git-stash-show"><a href="#git-stash-show" class="headerlink" title="git stash show"></a>git stash show</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">显示stash的具体内容是什么,用法:git stash show stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/" rel="tag">git</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-vue相关面试题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/09/vue%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"
    >vue相关面试题</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/06/09/vue%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time datetime="2020-06-08T16:00:00.000Z" itemprop="datePublished">2020-06-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/">web前端面试</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="1-对vue的理解"><a href="#1-对vue的理解" class="headerlink" title="1.对vue的理解"></a>1.对vue的理解</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vue: vue核心的一个概念,就是让用户不在操作dom元素,让程序员有更多的时间去关注业务逻辑,提高开发效率</span><br><span class="line">vue 是什么是一套前端开发框架(侧重的是业务逻辑),不用考虑怎么操作dom,只要考虑逻辑和数据,也就是响应式数据,数据改了,不用改代码,界面也立刻就变了.因此让程序员有更多的时间去关注业务逻辑,提高开发效率</span><br></pre></td></tr></table></figure>

<h2 id="2-框架和库的区别"><a href="#2-框架和库的区别" class="headerlink" title="2.框架和库的区别"></a>2.框架和库的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">框架:是一套完整的解决方案;对项目的侵入性较大,项目如果需要更换框架,则需要重新架构整个项目</span><br><span class="line">库(插件):提供某一个小功能,对项目的侵入性较小,如果某个库无法完成某些需求,可以很容易的切换到其他库实         现需求</span><br></pre></td></tr></table></figure>

<h2 id="3-Node-后端-的MVC-和-前端的MVVM之间的区别"><a href="#3-Node-后端-的MVC-和-前端的MVVM之间的区别" class="headerlink" title="3.Node(后端)的MVC 和 前端的MVVM之间的区别"></a>3.Node(后端)的MVC 和 前端的MVVM之间的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MVC(Model模型层,主要处理数据 View视图层,就是前端页面 Controller控制器,处理业务逻辑) 是后端的分层     开发概念</span><br><span class="line">MVVM(Model-View-ViewModel的简写) 是前端视图层的分层开发思想,主要把每个页面分成了M V 和VM,VM是	MVVM思想的核心,因为VM是M和V之间的调度者</span><br><span class="line">	 M                           VM                             			 V</span><br><span class="line">这里的M保存的是每个    VM是一个调度着,分割了M和V,每当V层                就是每个页面中的HTML结构</span><br><span class="line">页面中单独的数据     想要获取或者保存数据的时候,都要由VM做中间的处理</span><br><span class="line"></span><br><span class="line">前端页面中使用MVVM的思想,主要是为了让我们开发更加方便,因为MVVM提供了数据的双向绑定,通过双向数据绑定把view层和model层连接了起来,因此开发只需关注业务逻辑,不需要手动操作DOM,不需要关注数据状态的同步问题,从而提高开发效率.数据的双向绑定是由VM提供的</span><br></pre></td></tr></table></figure>

<h2 id="4-vue的生命周期函数"><a href="#4-vue的生命周期函数" class="headerlink" title="4.vue的生命周期函数"></a>4.vue的生命周期函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">什么是声明周期:从Vue实例创建,运行,到销毁阶段,总是伴随着各种各样的事件,这些事件统称为生命周期生命周     期钩子就是生命周期事件的别名</span><br><span class="line"></span><br><span class="line">组件创建阶段的四个生命周期函数</span><br><span class="line">1.beforeCreate:在执行这个函数的时候,data和methods中的数据还没有初始化,这时候只是刚刚初始化了一个       空的vue实例</span><br><span class="line">2.created:在create中,data和methods都已经被初始化好了,如果想要操作data中的数据或者调用methods中       的方法,最早只能在created中操作</span><br><span class="line">3.beforeMount:此函数执行的时候,模板已经在内存中编译好了,但是尚未挂载到页面上去,此时页面还旧的</span><br><span class="line">4.mounted:页面已经渲染完毕,如果想要操作页面上的dom元素,最早只能在mounted中</span><br><span class="line"></span><br><span class="line">组件运行阶段的生命周期函数</span><br><span class="line">5.beforeUpdate:当执行这个函数的时候.数据已经改变,只是更新过的数据还在内存中,此时页面中显示的数据       还是旧的</span><br><span class="line">6.updated:当执行这个函数的时候,页面中的数据已经是最新的了</span><br><span class="line"></span><br><span class="line">组件销毁阶段的生命周期函数</span><br><span class="line">7.beforeDestroy:当执行这个函数的时候,实例身上的所有数据和方法等都还是可用状态,还没有真正执行销毁</span><br><span class="line">8.destroyed:当执行这个函数的时候,组件已经被销毁,此时组件中的所有数据和方法都已经不可用了</span><br><span class="line"></span><br><span class="line">&lt;keep-alive&gt; 的作用,让组件不被销毁,当跳转到另一个页面的时候,在回来还是原来的状态</span><br><span class="line">当组件在&lt;keep-alive&gt;&lt;&#x2F;keep-alive&gt;中被切换的时候,会触发activated 和 deactivated 这两个生命周期</span><br><span class="line">9.activated:组件被激活的时候会调用(组件看得见的时候)</span><br><span class="line">10.deactivated:未激活的时候被调用(组件看不见的时候)</span><br></pre></td></tr></table></figure>

<h2 id="5-计算属性的用法"><a href="#5-计算属性的用法" class="headerlink" title="5.计算属性的用法"></a>5.计算属性的用法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    author: <span class="built_in">String</span> <span class="comment">//author是父组件传递进来的数据</span></span><br><span class="line">&#125;</span><br><span class="line">computed: &#123;</span><br><span class="line">    name () &#123;	<span class="comment">//name的值依赖于author的值,author的值改变,相应的name值也会改变</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.author</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-过滤器的用法"><a href="#6-过滤器的用法" class="headerlink" title="6.过滤器的用法"></a>6.过滤器的用法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//局部过滤器,在某个组件内部,与methods同级</span></span><br><span class="line">filters:&#123;</span><br><span class="line">	formatTime(value)&#123;</span><br><span class="line">        <span class="comment">//value是需要格式化的值</span></span><br><span class="line">        <span class="keyword">return</span>	<span class="comment">//最后返回的数据就是已经过滤后的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局过滤器,写在main.js中</span></span><br><span class="line"><span class="comment">//参数1:过滤器的名字,参数2:回调函数</span></span><br><span class="line">Vue.filter(<span class="string">'formatTime'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value, format</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> moment(value).format(format)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="7-侦听器的用法"><a href="#7-侦听器的用法" class="headerlink" title="7.侦听器的用法"></a>7.侦听器的用法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带参数的侦听器,可以比较两次数据的异同</span></span><br><span class="line">watch:&#123;</span><br><span class="line">	msg(newValue,oldValue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度侦听</span></span><br><span class="line">watch:&#123;</span><br><span class="line">    <span class="comment">//如果侦听的是对象,修改的数据是对象里的属性,需要用到深度侦听或者直接侦听 对象.属性</span></span><br><span class="line">    obj:&#123;</span><br><span class="line">        <span class="comment">//侦听的对象</span></span><br><span class="line">        handler(newValue,oldValue)&#123;	</span><br><span class="line">      <span class="comment">//侦听复杂数据类型的时候,传入的参数,是数据的地址,所以两个参数的值是一样的,基本数据类型的两个参数是不同的</span></span><br><span class="line">           <span class="comment">// 但是如果侦听的是精确到对象属性名,就可以避免这个问题了(新旧值是一样的)</span></span><br><span class="line">            <span class="built_in">console</span>.log(newValue,oldValue)	<span class="comment">//true</span></span><br><span class="line">        &#125;</span><br><span class="line">        deep:<span class="literal">true</span>	<span class="comment">//开启深度侦听</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-vue中methods-computed-watch三者的区别"><a href="#8-vue中methods-computed-watch三者的区别" class="headerlink" title="8.vue中methods,computed,watch三者的区别"></a>8.vue中methods,computed,watch三者的区别</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">methods里面的方法,一般是有触发条件的,需要调用才会执行</span><br><span class="line">computed计算属性,计算属性是根据他的依赖值计算的,当依赖值发生改变.其也会跟着改变,计算属性是依赖缓存</span><br><span class="line">	使用:<span class="number">1.</span>模板中使用&#123;&#123;&#125;&#125;渲染  <span class="number">2.</span>需要<span class="keyword">return</span>  <span class="number">3.</span>其他属性变化时不会触发当前属性变化,把耗能的计算都放在这里</span><br><span class="line">watch:方法名必须是属性名,并且要用字符串包起来,不需要<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">filter:需要参数</span><br><span class="line"></span><br><span class="line">watch 和 updated 的区别</span><br><span class="line">watch只会监听你在watch里写的那些属性,仅仅是数据发生改变</span><br><span class="line">updated数据发生改变并且界面上更新完毕,不能监听路由的数据(网址),所有数据发生改变都会调用updated</span><br></pre></td></tr></table></figure>

<h2 id="9-双向数据绑定的原理"><a href="#9-双向数据绑定的原理" class="headerlink" title="9.双向数据绑定的原理"></a>9.双向数据绑定的原理</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"txt"</span> <span class="attr">v-model</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-bind</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> txt = <span class="built_in">document</span>.querySelector(<span class="string">'[v-model]'</span>)</span><br><span class="line">     txt.oninput = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="comment">// console.log(txt.value)</span></span><br><span class="line">        data.name = txt.value      </span><br><span class="line">   	 &#125;</span><br><span class="line">     <span class="comment">// 给对象添加属性的语法</span></span><br><span class="line">     <span class="keyword">var</span> data = &#123;&#125;</span><br><span class="line"><span class="comment">//Object.defineProperty()是一种es6的给对象添加属性的方式,这样加属性的好处是,可以监听属性的赋值和取值,</span></span><br><span class="line"><span class="comment">//当给这个属性赋值时就会调用set方法,取值时就会调用get方法</span></span><br><span class="line">比如以下</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">'name'</span>,&#123;</span><br><span class="line">    <span class="keyword">get</span>()&#123;</span><br><span class="line">        <span class="comment">//规范 取值方式 return _属性名</span></span><br><span class="line">        <span class="keyword">return</span> _name</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(value)&#123; <span class="comment">//value是你赋的值</span></span><br><span class="line">        <span class="comment">//规范 赋值方式 _属性名=value</span></span><br><span class="line">        _name = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//双向绑定原理----比如把input输入的值双向绑定到p标签中</span></span><br><span class="line"><span class="comment">//使用Object.defineProperty()方法给对象动态的添加一个属性,这个方法有三个参数,参数1是对象,参数2是要给对象添加的属性,参数3是一个对象,对象里有get和set方法,当取属性的值时调用get方法,当给属性赋值时调用set方法.然后给input标签绑定一个输入事件,取到input标签的值赋值给对象的属性,此时会调用set方法,在set方法里再把值赋给p标签,此时就完成了数据的双向绑定</span></span><br></pre></td></tr></table></figure>

<h2 id="10-vue3-x双向绑定原理"><a href="#10-vue3-x双向绑定原理" class="headerlink" title="10.vue3.x双向绑定原理"></a>10.vue3.x双向绑定原理</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue3.x双向绑定原理,与vue2.x双向绑定原理其实是一样的,只是他用的是Proxy,它的特点是对象里的任何属性都会调用get和set方法,而且它能监听多个属性</span></span><br><span class="line"><span class="comment">//使用的是proxy(),它里面有两个参数,参数1是需要绑定的对象,参数2是一个对象</span></span><br><span class="line"><span class="keyword">let</span> proxyData = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data,&#123;</span><br><span class="line">    <span class="keyword">get</span>(obj,prop)&#123;</span><br><span class="line">        <span class="comment">//obj就是绑定的data对象,props就是要给对象添加的属性</span></span><br><span class="line">        <span class="keyword">return</span> obj[prop]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(obj,prop,value)&#123;</span><br><span class="line">    	<span class="comment">// value就是赋的值</span></span><br><span class="line">    	obj[prop] = value</span><br><span class="line"> 		<span class="comment">//最后再把值赋值给p标签</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>





 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-my面试代码题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/09/my%E9%9D%A2%E8%AF%95%E4%BB%A3%E7%A0%81%E9%A2%98/"
    >代码面试题</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/06/09/my%E9%9D%A2%E8%AF%95%E4%BB%A3%E7%A0%81%E9%A2%98/" class="article-date">
  <time datetime="2020-06-08T16:00:00.000Z" itemprop="datePublished">2020-06-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/">web前端面试</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="关于发送异步请求"><a href="#关于发送异步请求" class="headerlink" title="关于发送异步请求"></a>关于发送异步请求</h2><h2 id="1-原生ajax发get请求"><a href="#1-原生ajax发get请求" class="headerlink" title="1.原生ajax发get请求"></a>1.原生ajax发get请求</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建xhr对象</span></span><br><span class="line">	<span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="comment">//2.设置open()方法,get/post请求的地址</span></span><br><span class="line">	xhr.open(<span class="string">'get'</span>,<span class="string">'url地址'</span>) <span class="comment">// 参数1:请求的方法,参数2:请求的地址,参数以问号的形式拼接在请求地址后面</span></span><br><span class="line"><span class="comment">//3.设置响应成功后的回调函数</span></span><br><span class="line">	xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//在onload事件里拿到服务器返回的数据</span></span><br><span class="line">		<span class="built_in">console</span>.log(xhr.responseText)</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//4.发送请求</span></span><br><span class="line">	xhr.send()</span><br></pre></td></tr></table></figure>

<h2 id="2-原生ajax发post请求"><a href="#2-原生ajax发post请求" class="headerlink" title="2.原生ajax发post请求"></a>2.原生ajax发post请求</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建xhr对象</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="comment">//2.调用open方法设置请求方式和请求地址</span></span><br><span class="line">xhr.open(<span class="string">'post'</span>,<span class="string">'url地址'</span>)</span><br><span class="line"><span class="comment">//3.监听响应完成事件</span></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xhr.responseText)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.post请求方式要设置非请求头</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">'Content-type'</span>,<span class="string">'application/x-www-form-urlencoded'</span>)</span><br><span class="line"><span class="comment">//5.发送请求,多个参数之间也是用&amp;连接</span></span><br><span class="line">xhr.send(<span class="string">'参数'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-原生ajax请求兼容IE8写法"><a href="#3-原生ajax请求兼容IE8写法" class="headerlink" title="3.原生ajax请求兼容IE8写法"></a>3.原生ajax请求兼容IE8写法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建xhr对象</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="comment">//2.调用open方法,设置请求方式和请求路径</span></span><br><span class="line">xhr.open(<span class="string">'get'</span>,<span class="string">'url地址'</span>)</span><br><span class="line"><span class="comment">//3.监听响应完成事件,onreadystatechange兼容onload,所有浏览器都支持</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//在里面做判断,事件状态码为4才能保证响应的数据是完整的,并且响应状态码为200代表响应成功</span></span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.state == <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(xhr.responseText);<span class="comment">//得到相应内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.发送请求</span></span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure>

<h2 id="4-jQuery发ajax请求get方式"><a href="#4-jQuery发ajax请求get方式" class="headerlink" title="4.jQuery发ajax请求get方式"></a>4.jQuery发ajax请求get方式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>(&#123;</span><br><span class="line">	url:<span class="string">'请求地址'</span>,</span><br><span class="line">    data:&#123;<span class="string">'请求参数,键值对的形式'</span>&#125;,</span><br><span class="line">    dataType:<span class="string">'json'</span>,	<span class="comment">//如果返回回来的数据是json字符串,设置dataType为json能把json字符串转化成js对象</span></span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)	<span class="comment">//回调函数里对返回数据的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="5-jQuery发ajax请求post方式"><a href="#5-jQuery发ajax请求post方式" class="headerlink" title="5.jQuery发ajax请求post方式"></a>5.jQuery发ajax请求post方式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果post请求的参数是form表单,并且需要上传头像的,要用FormData对象,用这个对象可以上传头像,并且可以获取表单中的所有内容,在new它的时候,参数要求传入表单元素(只能是DOM对象,不能是jQuery对象),要使用FromData对象,必须要在form表单里添加name属性,并且name属性的值就是请求的参数名</span></span><br><span class="line"><span class="keyword">var</span> fm = <span class="keyword">new</span> FormData($(<span class="string">'form'</span>)[<span class="number">0</span>])</span><br><span class="line">$.post(&#123;</span><br><span class="line">    url:<span class="string">'请求地址'</span>,</span><br><span class="line">    data:fm,	<span class="comment">//参数使用FormData对象</span></span><br><span class="line">    <span class="comment">//但是注意,jQuery里如果要传FormData对象,还必须加以下两句话</span></span><br><span class="line">    contentType:<span class="literal">false</span>,</span><br><span class="line">    processData:<span class="literal">false</span>,</span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)	<span class="comment">//对响应回来的数据的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//1.解释,使用FormData为什么要加contentType:false</span></span><br><span class="line"><span class="comment">//因为FormData会自动帮我们加请求头,而jQuery也会加,那么就冲突了,所以加了这句话是为了告诉jQuery,不用帮我加请求头了,用FormData加的请求头就好来了</span></span><br><span class="line"><span class="comment">//2.解释,使用FormData为什么要加processData:false</span></span><br><span class="line"><span class="comment">//因为FromData本身就是一个对象,而jQuery会把对象转换成字符串,但是FromData我不需要转成字符串,所以加这句话的意思就是我不需要你把我这个对象转成字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//serialize,jQuery的一个方法,发送post请求可以一次性提交表单的内容,也需要给表单添加name属性</span></span><br><span class="line"><span class="keyword">var</span> data = $(<span class="string">'选择器'</span>).serialize()</span><br></pre></td></tr></table></figure>

<h2 id="6-axios的简单用法"><a href="#6-axios的简单用法" class="headerlink" title="6.axios的简单用法"></a>6.axios的简单用法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在main.js中导入axios</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="comment">//把axios添加给Vue的原型,那么Vue的实例都可以使用了</span></span><br><span class="line">Vue.prototype.$axios = axios</span><br><span class="line"><span class="comment">//设置基地址</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">'基地址'</span></span><br><span class="line"></span><br><span class="line">vue实例要用直接<span class="keyword">this</span>.$axios,参数根据接口文档说明</span><br><span class="line"><span class="keyword">this</span>.$axios.get(<span class="string">'url地址'</span>)</span><br><span class="line">.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(请求成功后的回调函数)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="7-axios的抽取"><a href="#7-axios的抽取" class="headerlink" title="7.axios的抽取"></a>7.axios的抽取</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把关于axios的抽取成单独的文件,然后在main.js中导入该文件就可以了</span></span><br><span class="line"><span class="comment">//设置多基地址</span></span><br><span class="line"><span class="keyword">const</span> http = axios.create(&#123;</span><br><span class="line">    baseUrl:<span class="string">'url地址'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="8-axios设置请求拦截"><a href="#8-axios设置请求拦截" class="headerlink" title="8.axios设置请求拦截"></a>8.axios设置请求拦截</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//把所有的请求拦截下来</span></span><br><span class="line">	<span class="keyword">return</span> config</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//发生错误的回调函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="9-微信小程序的异步请求封装"><a href="#9-微信小程序的异步请求封装" class="headerlink" title="9.微信小程序的异步请求封装"></a>9.微信小程序的异步请求封装</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用promise封装wx.request----单独建一个js文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myrequest</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 发送请求</span></span><br><span class="line">        wx.request(&#123;</span><br><span class="line">            url:options.url,</span><br><span class="line">            method:options.method || <span class="string">"GET"</span>,</span><br><span class="line">            data:options.data || &#123;&#125;,</span><br><span class="line">            header:options.header || &#123;&#125;,</span><br><span class="line">            success:<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                resolve(res)</span><br><span class="line">            &#125;,</span><br><span class="line">            fail:<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后将封装好的wx.request暴露出去</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> myrequest</span><br></pre></td></tr></table></figure>

<h2 id="10-用户在浏览器输入地址后否发生了什么事"><a href="#10-用户在浏览器输入地址后否发生了什么事" class="headerlink" title="10. 用户在浏览器输入地址后否发生了什么事"></a>10. 用户在浏览器输入地址后否发生了什么事</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">step0:当用户输入地址回车之后,浏览器首先会把这个地址交给DNS域名解析器,然后DNS查找到对应的域名返回给浏览器</span><br><span class="line">step1:浏览器发送请求给服务器</span><br><span class="line">step2:服务器端接收到请求 并 获取浏览器需要的资源</span><br><span class="line">step3:服务器将获取到的数据响应给浏览器</span><br><span class="line">step4:浏览器接收响应的数据</span><br><span class="line">step5:浏览器通过js引擎来解析js,通过渲染引擎来渲染html,css</span><br><span class="line">step6:将内容显示给用户</span><br></pre></td></tr></table></figure>

<h2 id="vue-相关面试题"><a href="#vue-相关面试题" class="headerlink" title="vue 相关面试题"></a>vue 相关面试题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vue:vue核心的一个概念,就是让用户不在操作dom元素,让程序员有更多的时间去关注业务逻辑,提高开发效率</span><br><span class="line">vue 是什么:是一套前端开发框架(侧重的是业务逻辑),不用考虑怎么操作dom,只要考虑逻辑和数据,也就是响应	    式数据,数据改了,不用改代码,界面也立刻就变了.因此让程序员有更多的时间去关注业务逻辑,提高开发效率</span><br></pre></td></tr></table></figure>

<h2 id="1-框架和库的区别"><a href="#1-框架和库的区别" class="headerlink" title="1.框架和库的区别"></a>1.框架和库的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">框架:是一套完整的解决方案;对项目的侵入性较大,项目如果需要更换框架,则需要重新架构整个项目</span><br><span class="line">库(插件):提供某一个小功能,对项目的侵入性较小,如果某个库无法完成某些需求,可以很容易的切换到其他库实         现需求</span><br></pre></td></tr></table></figure>

<h2 id="2-Node-后端-的MVC-和-前端的MVVM之间的区别"><a href="#2-Node-后端-的MVC-和-前端的MVVM之间的区别" class="headerlink" title="2.Node(后端)的MVC 和 前端的MVVM之间的区别"></a>2.Node(后端)的MVC 和 前端的MVVM之间的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MVC(Model模型层,主要处理数据 View视图层,就是前端页面 Controller控制器,处理业务逻辑) 是后端的分层     开发概念</span><br><span class="line">MVVM(Model-View-ViewModel的简写) 是前端视图层的分层开发思想,主要把每个页面分成了M V 和VM,VM是	MVVM思想的核心,因为VM是M和V之间的调度者</span><br><span class="line">	 M                           VM                             			 V</span><br><span class="line">这里的M保存的是每个    VM是一个调度着,分割了M和V,每当V层                就是每个页面中的HTML结构</span><br><span class="line">页面中单独的数据     想要获取或者保存数据的时候,都要由VM做中间的处理</span><br><span class="line"></span><br><span class="line">前端页面中使用MVVM的思想,主要是为了让我们开发更加方便,因为MVVM提供了数据的双向绑定,通过双向数据绑定把view层和model层连接了起来,因此开发只需关注业务逻辑,不需要手动操作DOM,不需要关注数据状态的同步问题,从而提高开发效率.数据的双向绑定是由VM提供的</span><br></pre></td></tr></table></figure>

<h2 id="3-vue的生命周期函数"><a href="#3-vue的生命周期函数" class="headerlink" title="3.vue的生命周期函数"></a>3.vue的生命周期函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">什么是声明周期:从Vue实例创建,运行,到销毁阶段,总是伴随着各种各样的事件,这些事件统称为生命周期生命周     期钩子就是生命周期事件的别名</span><br><span class="line"></span><br><span class="line">组件创建阶段的四个生命周期函数</span><br><span class="line">1.beforeCreate:在执行这个函数的时候,data和methods中的数据还没有初始化,这时候只是刚刚初始化了一个       空的vue实例</span><br><span class="line">2.created:在create中,data和methods都已经被初始化好了,如果想要操作data中的数据或者调用methods中       的方法,最早只能在created中操作</span><br><span class="line">3.beforeMount:此函数执行的时候,模板已经在内存中编译好了,但是尚未挂载到页面上去,此时页面还旧的</span><br><span class="line">4.mounted:页面已经渲染完毕,如果想要操作页面上的dom元素,最早只能在mounted中</span><br><span class="line"></span><br><span class="line">组件运行阶段的生命周期函数</span><br><span class="line">5.beforeUpdate:当执行这个函数的时候.数据已经改变,只是更新过的数据还在内存中,此时页面中显示的数据       还是旧的</span><br><span class="line">6.updated:当执行这个函数的时候,页面中的数据已经是最新的了</span><br><span class="line"></span><br><span class="line">组件销毁阶段的生命周期函数</span><br><span class="line">7.beforeDestroy:当执行这个函数的时候,实例身上的所有数据和方法等都还是可用状态,还没有真正执行销毁</span><br><span class="line">8.destroyed:当执行这个函数的时候,组件已经被销毁,此时组件中的所有数据和方法都已经不可用了</span><br><span class="line"></span><br><span class="line">&lt;keep-alive&gt; 的作用,让组件不被销毁,当跳转到另一个页面的时候,在回来还是原来的状态</span><br><span class="line">当组件在&lt;keep-alive&gt;&lt;&#x2F;keep-alive&gt;中被切换的时候,会触发activated 和 deactivated 这两个生命周期</span><br><span class="line">9.activated:组件被激活的时候会调用(组件看得见的时候)</span><br><span class="line">10.deactivated:未激活的时候被调用(组件看不见的时候)</span><br></pre></td></tr></table></figure>

<h2 id="4-计算属性的用法"><a href="#4-计算属性的用法" class="headerlink" title="4. 计算属性的用法"></a>4. 计算属性的用法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-过滤器的用法"><a href="#5-过滤器的用法" class="headerlink" title="5.过滤器的用法"></a>5.过滤器的用法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//局部过滤器,在某个组件内部,与methods同级</span></span><br><span class="line">filters:&#123;</span><br><span class="line">	formatTime(value)&#123;</span><br><span class="line">        <span class="comment">//value是需要格式化的值</span></span><br><span class="line">        <span class="keyword">return</span>	<span class="comment">//最后返回的数据就是已经过滤后的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局过滤器,写在main.js中</span></span><br><span class="line"><span class="comment">//参数1:过滤器的名字,参数2:回调函数</span></span><br><span class="line">Vue.filter(<span class="string">'formatTime'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value, format</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> moment(value).format(format)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="6-侦听器的用法"><a href="#6-侦听器的用法" class="headerlink" title="6.侦听器的用法"></a>6.侦听器的用法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带参数的侦听器,可以比较两次数据的异同</span></span><br><span class="line">watch:&#123;</span><br><span class="line">	msg(newValue,oldValue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度侦听</span></span><br><span class="line">watch:&#123;</span><br><span class="line">    <span class="comment">//如果侦听的是对象,修改的数据是对象里的属性,需要用到深度侦听或者直接侦听 对象.属性</span></span><br><span class="line">    obj:&#123;</span><br><span class="line">        <span class="comment">//侦听的对象</span></span><br><span class="line">        handler(newValue,oldValue)&#123;	</span><br><span class="line">      <span class="comment">//侦听复杂数据类型的时候,传入的参数,是数据的地址,所以两个参数的值是一样的,基本数据类型的两个参数是不同的</span></span><br><span class="line">           <span class="comment">// 但是如果侦听的是精确到对象属性名,就可以避免这个问题了(新旧值是一样的)</span></span><br><span class="line">            <span class="built_in">console</span>.log(newValue,oldValue)	<span class="comment">//true</span></span><br><span class="line">        &#125;</span><br><span class="line">        deep:<span class="literal">true</span>	<span class="comment">//开启深度侦听</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-vue中methods-computed-watch三者的区别"><a href="#7-vue中methods-computed-watch三者的区别" class="headerlink" title="7.vue中methods,computed,watch三者的区别"></a>7.vue中methods,computed,watch三者的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">methods里面的方法,一般是有触发条件的,需要调用才会执行</span><br><span class="line">computed计算属性,计算属性是根据他的依赖值计算的,当依赖值发生改变.其也会跟着改变,计算属性是依赖缓存</span><br><span class="line">	使用:1.模板中使用&#123;&#123;&#125;&#125;渲染  2.需要return  3.其他属性变化时不会触发当前属性变化,把耗能的计算都放在这里</span><br><span class="line">watch:方法名必须是属性名,并且要用字符串包起来,不需要return</span><br><span class="line"></span><br><span class="line">filter:需要参数</span><br><span class="line"></span><br><span class="line">watch 和 updated 的区别</span><br><span class="line">watch只会监听你在watch里写的那些属性,仅仅是数据发生改变</span><br><span class="line">updated数据发生改变并且界面上更新完毕,不能监听路由的数据(网址),所有数据发生改变都会调用updated</span><br></pre></td></tr></table></figure>

<h2 id="8-双向数据绑定的原理"><a href="#8-双向数据绑定的原理" class="headerlink" title="8.双向数据绑定的原理"></a>8.双向数据绑定的原理</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"txt"</span> <span class="attr">v-model</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-bind</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> txt = <span class="built_in">document</span>.querySelector(<span class="string">'[v-model]'</span>)</span><br><span class="line">     txt.oninput = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="comment">// console.log(txt.value)</span></span><br><span class="line">        data.name = txt.value      </span><br><span class="line">   	 &#125;</span><br><span class="line">     <span class="comment">// 给对象添加属性的语法</span></span><br><span class="line">     <span class="keyword">var</span> data = &#123;&#125;</span><br><span class="line"><span class="comment">//Object.defineProperty()是一种es6的给对象添加属性的方式,这样加属性的好处是,可以监听属性的赋值和取值,</span></span><br><span class="line"><span class="comment">//当给这个属性赋值时就会调用set方法,取值时就会调用get方法</span></span><br><span class="line">比如以下</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">'name'</span>,&#123;</span><br><span class="line">    <span class="keyword">get</span>()&#123;</span><br><span class="line">        <span class="comment">//规范 取值方式 return _属性名</span></span><br><span class="line">        <span class="keyword">return</span> _name</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(value)&#123; <span class="comment">//value是你赋的值</span></span><br><span class="line">        <span class="comment">//规范 赋值方式 _属性名=value</span></span><br><span class="line">        _name = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//双向绑定原理----比如把input输入的值双向绑定到p标签中</span></span><br><span class="line"><span class="comment">//使用Object.defineProperty()方法给对象动态的添加一个属性,这个方法有三个参数,参数1是对象,参数2是要给对象添加的属性,参数3是一个对象,对象里有get和set方法,当取属性的值时调用get方法,当给属性赋值时调用set方法.然后给input标签绑定一个输入事件,取到input标签的值赋值给对象的属性,此时会调用set方法,在set方法里再把值赋给p标签,此时就完成了数据的双向绑定</span></span><br></pre></td></tr></table></figure>

<h2 id="9-vue3-x双向绑定原理"><a href="#9-vue3-x双向绑定原理" class="headerlink" title="9.vue3.x双向绑定原理"></a>9.vue3.x双向绑定原理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue3.x双向绑定原理,与vue2.x双向绑定原理其实是一样的,只是他用的是Proxy,它的特点是对象里的任何属性都会调用get和set方法,而且它能监听多个属性</span></span><br><span class="line"><span class="comment">//使用的是proxy(),它里面有两个参数,参数1是需要绑定的对象,参数2是一个对象</span></span><br><span class="line"><span class="keyword">let</span> proxyData = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data,&#123;</span><br><span class="line">    <span class="keyword">get</span>(obj,prop)&#123;</span><br><span class="line">        <span class="comment">//obj就是绑定的data对象,props就是要给对象添加的属性</span></span><br><span class="line">        <span class="keyword">return</span> obj[prop]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(obj,prop,value)&#123;</span><br><span class="line">    	<span class="comment">// value就是赋的值</span></span><br><span class="line">    	obj[prop] = value</span><br><span class="line"> 		<span class="comment">//最后再把值赋值给p标签</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="10-vue中hash模式和history模式"><a href="#10-vue中hash模式和history模式" class="headerlink" title="10. vue中hash模式和history模式"></a>10. vue中hash模式和history模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hash和history是vue-router的两种路由模式,vue-router默认的是hash模式</span><br><span class="line">外观上的区别:</span><br><span class="line">	hash模式的url里永远带有#号,而history的作用就是美化url</span><br><span class="line">功能上的区别:</span><br><span class="line">	hash模式:当hash值发生改变的时候,不会刷新页面,因为url的hash值不包含在http请求中</span><br><span class="line">	history模式:前端的url必须和实际向后端发请求的url一致,如果不一致,就会返回404错误,所以如果想要history模式,	    还需要后端配置url的重定向(将不存在的路径请求重定向到入口文件)</span><br><span class="line">使用history:在路由中添加:mode:&#39;history&#39;</span><br></pre></td></tr></table></figure>

<h2 id="11-vue-router的传参"><a href="#11-vue-router的传参" class="headerlink" title="11.vue-router的传参"></a>11.vue-router的传参</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一:</span></span><br><span class="line"><span class="comment">//路由配置,在routes中</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123;<span class="attr">path</span>:<span class="string">'/detail/:id'</span>,<span class="attr">component</span>:login&#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment">//路由跳转,在组件中</span></span><br><span class="line"><span class="keyword">this</span>.$router.push(<span class="string">"/detail/"</span>+id)</span><br><span class="line"><span class="comment">//接收参数</span></span><br><span class="line"><span class="keyword">this</span>.$route.params.id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二:通过name来确定匹配的路由,通过params来传递参数</span></span><br><span class="line"><span class="comment">//路由配置,在routes中</span></span><br><span class="line">&#123;</span><br><span class="line">    path:<span class="string">'/detail'</span>,</span><br><span class="line">    name:<span class="string">'detail'</span>,	<span class="comment">//通过name匹配路由</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//路由跳转,在组件中</span></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123;</span><br><span class="line">    name:<span class="string">'detail'</span>,	<span class="comment">//匹配的路由</span></span><br><span class="line">    params:&#123;</span><br><span class="line">        id:id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//接收参数</span></span><br><span class="line"><span class="keyword">this</span>.$route.params.id</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//方式三:通过query传参</span></span><br><span class="line"><span class="comment">//路由配置,在routes中</span></span><br><span class="line">&#123;</span><br><span class="line">    path:<span class="string">'/detail'</span>,</span><br><span class="line">    name:<span class="string">'detail'</span>,	<span class="comment">//通过name匹配路由</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传参,在路由中</span></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123;</span><br><span class="line">    path:<span class="string">'/detail'</span>,</span><br><span class="line">    query:&#123;</span><br><span class="line">        id:id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//接收参数</span></span><br><span class="line">    <span class="keyword">this</span>.$route.query.id</span><br><span class="line"></span><br><span class="line">query相当于<span class="keyword">get</span>请求,页面跳转的时候可以在地址栏看到请求参数</span><br><span class="line"> 而params相当于post请求</span><br></pre></td></tr></table></figure>

<h2 id="12-vue的set方法"><a href="#12-vue的set方法" class="headerlink" title="12.vue的set方法"></a>12.vue的set方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		obj:&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 想动态的给obj添加属性,最好用set方法</span></span><br><span class="line">created()&#123;</span><br><span class="line">	<span class="keyword">this</span>.$<span class="keyword">set</span>(this.obj,'name','Jack')</span><br><span class="line">	// 参数1是对象,参数二是对象添加的属性,参数3是对象的属性的值,这种方法添加属性能保证数据双向绑定</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vue组件之间的传参"><a href="#vue组件之间的传参" class="headerlink" title="vue组件之间的传参"></a>vue组件之间的传参</h2><h2 id="1-父组件给子组件传参"><a href="#1-父组件给子组件传参" class="headerlink" title="1.父组件给子组件传参"></a>1.父组件给子组件传参</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">步骤:1.父传	2.子接</span><br><span class="line">父传:父组件中有一个参数,通过自定义组件传递给子组件</span><br><span class="line">子接:通过props属性来进行接收</span><br><span class="line">	补充:props的属性值可以是数组[],也可以是对象&#123;&#125;</span><br><span class="line">比如说参数名是datamsg</span><br><span class="line">	数组:props:[&#39;datamsg&#39;]</span><br><span class="line">	对象:props:&#123;</span><br><span class="line">		datamsg:&#123;</span><br><span class="line">			type:String,	&#x2F;&#x2F;参数的数据类型</span><br><span class="line">			default:&#39;默认值&#39; &#x2F;&#x2F;参数的默认值</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在父组件中的代码,父组件中与一个参数,通过自定义属性传递给子组件</span><br><span class="line">&lt;h1&gt;我是父组件&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">   msg: &#123;&#123; msg &#125;&#125;	&#x2F;&#x2F;父组件中的参数msg</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;son v-bind:data&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;son&gt;	&#x2F;&#x2F;通过自定义属性data传递给子组件son</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在子组件中的代码,通过props接收</span><br><span class="line">props:[&#39;data&#39;]  或者  props:&#123;data:&#123;type:String,default:&#39;默认值&#39;&#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//1.子组件里写一个props,它是一个数组,数组里定义需要几个值</span><br><span class="line">props:['first','second']	//代表需要两个,分别叫first和second</span><br><span class="line">//2.在调用这个子组件的地方,写标签,再给标签里写行内属性,依次传值</span><br><span class="line"><span class="tag">&lt;<span class="name">bread</span> <span class="attr">first</span>=<span class="string">'权限管理'</span> <span class="attr">second</span>=<span class="string">'权限列表'</span>&gt;</span><span class="tag">&lt;/<span class="name">bread</span>&gt;</span> 代表给bread传递first和second两个值</span><br></pre></td></tr></table></figure>



<h2 id="2-子组件给父组件传值"><a href="#2-子组件给父组件传值" class="headerlink" title="2.子组件给父组件传值"></a>2.子组件给父组件传值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">步骤:1.子传	2.父接</span><br><span class="line">子传:子组件中通过自定义事件$emit,将参数交给父组件</span><br><span class="line">父接:在父组件中实现子组件的自定义事件,并设置相应的函数</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;子传:写在子组件中的代码</span><br><span class="line">this.$emit(&#39;sendval&#39;, this.msg)	&#x2F;&#x2F;sendval是子组件自定义的事件名,this.msg是要传递给父组件的参数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;父接:写在父组件中的代码</span><br><span class="line">&lt;h1&gt;我是父组件&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;div&gt; msg: &#123;&#123;msg&#125;&#125; &lt;&#x2F;div&gt;</span><br><span class="line">&lt;son&gt; @sendval&#x3D;&quot;getVal&quot; &lt;&#x2F;son&gt;	&#x2F;&#x2F;在父组件中实现子组件中的自定义事件,getVal是设置的相应的函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在父组件中</span><br><span class="line">methods:&#123;</span><br><span class="line">	getVal(value)&#123;	&#x2F;&#x2F;通过设置的相应的函数,获取到子组件传递过来的参数,value就是子传父的参数</span><br><span class="line">		this.msg &#x3D; value</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-兄弟组件之间的传值"><a href="#3-兄弟组件之间的传值" class="headerlink" title="3.兄弟组件之间的传值"></a>3.兄弟组件之间的传值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">步骤:</span><br><span class="line">	1.创建一个单独的js文件,在文件中导出一个vue对象(bus)</span><br><span class="line">	2.son1将参数交给bus</span><br><span class="line">		在son1中引用bus对象,通过bus.$emit(&#39;fn&#39;,value)将参数交给bus</span><br><span class="line">		 bus.$emit(&#39;fn&#39;, this.msg)</span><br><span class="line">	3.bus将参数交给son2</span><br><span class="line">		在son2中引入bus对象,通过bus.$on(&#39;fn&#39;,function(value)&#123;&#125;)来接收参数</span><br><span class="line">		bus.$on(&#39;fn&#39;, value &#x3D;&gt; &#123;</span><br><span class="line">                this.msg &#x3D; value</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Vuex的使用"><a href="#Vuex的使用" class="headerlink" title="Vuex的使用"></a>Vuex的使用</h1><h2 id="1-vuex的基本使用"><a href="#1-vuex的基本使用" class="headerlink" title="1.vuex的基本使用"></a>1.vuex的基本使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">step1:下包:npm i vuex --save</span><br><span class="line">step2:导包:<span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line">		  Vue.use(Vuex)</span><br><span class="line">step3:实例化一个仓库</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state:&#123; <span class="comment">//相当于是vue里面的data</span></span><br><span class="line">    msg:<span class="string">'hello vuex'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations:&#123; <span class="comment">//相当于是vue里面的methods</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">step4:挂载store到vue的对象里,写在ne Vue 里面</span><br><span class="line"></span><br><span class="line">如果哪个组件需要使用,直接$store.state.msg</span><br></pre></td></tr></table></figure>

<h2 id="2-修改vuex的值"><a href="#2-修改vuex的值" class="headerlink" title="2. 修改vuex的值"></a>2. 修改vuex的值</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">step1:首先在在mutations里面写一个方法,如下</span><br><span class="line">mutations:&#123;</span><br><span class="line">    <span class="comment">//参数1state:就是store实例的对象state(能拿到数据)</span></span><br><span class="line">    <span class="comment">// 参数2value:是哪个组件需要改vuex里面的值,就是那个组件需要修改的值</span></span><br><span class="line">	xiugai(state,value)&#123;</span><br><span class="line">		state.msg = value</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">step2:比如说子组件son需要修改vuex的值,就在son组件里面使用store的commit方法</span><br><span class="line">methods:&#123;</span><br><span class="line">    <span class="comment">// 点击按钮触发sonChange方法</span></span><br><span class="line">    sonChange()&#123;</span><br><span class="line">        <span class="comment">// 参数1:xiugai是mutation里面的修改值的方法</span></span><br><span class="line">        <span class="comment">// 参数2:是son组件需要修改的值</span></span><br><span class="line">        <span class="keyword">this</span>.$store.commit(<span class="string">'xiugai'</span>,<span class="string">'son要修改的值'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用commit的方法修改vuex的值这种方法是官方推荐的方法</span></span><br><span class="line"><span class="comment">// 好处是:可以在vue-devtools工具里面追踪修改的值</span></span><br></pre></td></tr></table></figure>

<h2 id="3-vuex的计算属性getters"><a href="#3-vuex的计算属性getters" class="headerlink" title="3.vuex的计算属性getters"></a>3.vuex的计算属性getters</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">step1:直接在store里面写getters,与state和mutation同级</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">	state:&#123;&#125;,</span><br><span class="line">    mutations:&#123;&#125;,</span><br><span class="line">    getters:&#123;</span><br><span class="line">        msgLen()&#123; <span class="keyword">return</span> <span class="string">'计算的值'</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">step2:使用如下</span><br><span class="line">&#123;&#123; $store.getters.msgLen &#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-action-和-module"><a href="#4-action-和-module" class="headerlink" title="4. action 和 module"></a>4. action 和 module</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">action 类似于mutation,不同之处在于action提交的是mutation,而不是直接变更状态,action 可以包含任意一部操作</span><br><span class="line">mutation是同步的</span><br><span class="line"></span><br><span class="line">vuex允许我们将store分割成模块(<span class="built_in">module</span>),每个模块拥有自己的state、mutation、action、getter</span><br><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">    state:&#123;&#125;,</span><br><span class="line">    mutation:&#123;&#125;,</span><br><span class="line">    action:&#123;&#125;,</span><br><span class="line">    getter:&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">	state:&#123;&#125;,</span><br><span class="line">    mutation:&#123;&#125;,</span><br><span class="line">    action:&#123;&#125;,</span><br><span class="line">    getter:&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    modules:&#123;</span><br><span class="line">        moduleA,moduleB</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="1-mockjs"><a href="#1-mockjs" class="headerlink" title="1.mockjs"></a>1.mockjs</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">是什么: 是用来生成虚拟数据的工具</span><br><span class="line">有什么用:在开发过程中,前端可能会先完成工作,此时需要后端的接口,但是后端的接口还没写好,那么我们就可以使用mockjs来		生成一些虚拟的数据代替后端接口数据,等后端接口开发完成之后,再替换成真实的数据</span><br><span class="line">用法一:生成虚拟数据</span><br><span class="line">	1.安装:npm install mockjs</span><br><span class="line">	2.使用:</span><br><span class="line">	var Mock &#x3D; require(&#39;mockjs&#39;)	&#x2F;&#x2F;引用mockjs</span><br><span class="line">	var data &#x3D; Mock.mock(&#123;&#125;)		&#x2F;&#x2F;生成数据</span><br><span class="line">用法二:拦截异步请求</span><br><span class="line">	为什么需要拦截:因为前段开发比后端的快,很有可能,后端还没开发好接口,前端就要调用接口,如果直接请求,就会出现		404错误,为了解决这样的问题,需要拦截异步请求</span><br><span class="line">联调:将mock生成的虚拟数据替换成真实的接口数据的过程就是联调</span><br></pre></td></tr></table></figure>

<h2 id="2-vue-cli2-x-和-vue-cli3-x的区别"><a href="#2-vue-cli2-x-和-vue-cli3-x的区别" class="headerlink" title="2.vue-cli2.x 和 vue-cli3.x的区别"></a>2.vue-cli2.x 和 vue-cli3.x的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vue-cli</span><br><span class="line">是什么:一个脚手架工具</span><br><span class="line">有何用:搭建一个前端项目(前端项目工程化)</span><br><span class="line">vue-cli3.x用法:</span><br><span class="line">	1.安装:npm install -g @vue&#x2F;cli</span><br><span class="line">	2.创建项目:vue create 项目名</span><br><span class="line">	3.运行项目:npm run serve</span><br><span class="line">vue-cli2.x用法: 如果既要使用vue-cli3.0,又要使用vue-cli2.0,那么就要在中间先安装一个桥接工具</span><br><span class="line">	1.安装:npm i vue-cli -g   &#x2F;&#x2F; 这里安装的是 3.0 的版本，如果要使用 2.x 的模式需要安装桥接工具</span><br><span class="line">	  	  npm install -g @vue&#x2F;cli-init	&#x2F;&#x2F;安装桥接工具</span><br><span class="line">	2.生成项目:vue init webpack 项目名</span><br><span class="line">	3.运行项目:npm run dev</span><br><span class="line"></span><br><span class="line">对比区别:</span><br><span class="line">	运行方式不一样:</span><br><span class="line">        vue-cli3.0 npm run serve</span><br><span class="line">        vue-cli2.0 npm run dev</span><br><span class="line">	项目结构不一样:</span><br><span class="line">		配置信息:vue-cli3.0每个体系都有自己单独的配置文件</span><br><span class="line">		静态文件:放在public中</span><br><span class="line">		</span><br><span class="line">		配置信息:vue-cli2.0所有的配置都在build文件夹下</span><br><span class="line">		静态文件:直接在根目录下</span><br></pre></td></tr></table></figure>

<h2 id="3-session-cookie-token"><a href="#3-session-cookie-token" class="headerlink" title="3.session   cookie   token"></a>3.session   cookie   token</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">因为http是无状态的,每次浏览器向服务器发送请求都相当于是初次见面,比如你刚登录,等你再访问的时候还是要你登录,这样就不合理,所以就用cookie来解决这个问题,当浏览器第一次向服务器发送请求的时候,服务器会返回一个cookie做凭证,等下次浏览器再向服务器发送请求时就带上cookie,服务器端看到cookie,就知道该用户已经登录过,就可以访问了</span><br><span class="line">session也可以起到这个作用,那他们的区别就是: 															1.作用范围不同,cookie存储在浏览器,session存储在服务器												2.有效期不同,cookie可以设置存储时间,session只在当前会话有效,关闭浏览器后就无效了						3.安全性不同,cookie以明文的方式保存在浏览器,容易被伪造,不安全,session相对来说安全一点,因为session的值是		存储在服务器端的,只是把session的id存在cookie											</span><br><span class="line">token是本意是令牌,一般用来验证用户身份,token的安全性更高,当第一次向服务器端发送请求的时候,服务器会根据你的请求头,请求体,根据你的电脑环境生成一段独一无二的代码,这段代码就是token,然后返回给浏览器作为标识,等下次再向服务器发送请求的时候,带上token,服务器看到token就知道该用户已经登录过,可以访问,但是token不能自动存,也不能自动取,所以再第一次登录成功的时候就用localStorage把token存在浏览器,然后设置一个请求拦截,在每次发请求的时候带上token</span><br></pre></td></tr></table></figure>

<h2 id="4-localStorage-sessionStorage-cookie"><a href="#4-localStorage-sessionStorage-cookie" class="headerlink" title="4.localStorage     sessionStorage     cookie"></a>4.localStorage     sessionStorage     cookie</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">localStorage 和 sessionStorage 是对cookie存储机制的一个改善,是H5的新特性,都是存储在浏览器本地的</span><br><span class="line">1.生命周期:localStorage是永久性存储,一旦存储将不会消失,除非主动删除数据,就算关闭浏览器下次打开的时候还在,而sessionStorage存储的数据只在当前会话下有效,只要关闭了浏览器,数据就会消失,cookie的存储时间是可以设置的,超过了这个期限,cookie就无效,如果过期就再向服务器发一次请求就好了</span><br><span class="line">2.存储大小:localStorage 和 sessionStorage 的存储数据大小一般都是5MB,而cookie的存储数据大小在4kb</span><br><span class="line">3.存储位置:localStorage 和 sessionStorage都保存在客户端,不与服务器进行交互通信,cookie是由服务器端生成,返回到浏览器,并存储在浏览器端的</span><br><span class="line">4.作用域不同:sessionStorage不在不同的浏览器窗口中共享,即使是同一个页面,localStorage在所有的同源窗口中共享,cookie也是在所有同源窗口中共享</span><br></pre></td></tr></table></figure>

<h2 id="5-普通函数与箭头函数的区别"><a href="#5-普通函数与箭头函数的区别" class="headerlink" title="5.普通函数与箭头函数的区别"></a>5.普通函数与箭头函数的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.this指向问题</span><br><span class="line">	普通函数的this指向window,箭头函数的this指向它所在的上下文的this</span><br></pre></td></tr></table></figure>

<h2 id="6-深克隆和浅克隆"><a href="#6-深克隆和浅克隆" class="headerlink" title="6.深克隆和浅克隆"></a>6.深克隆和浅克隆</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">克隆只针对对象 数组 函数等复杂数据类型</span><br><span class="line">浅克隆:对象是存储在堆中的,只是把地址变量存储在栈中,浅拷贝就是复制栈中的地址,实际上两者指向的还是同一对象,其中一个改变了,另一个也会跟着改变</span><br><span class="line">深克隆:创建一个空的对象,开辟一块新的空间,然后将原来对象中的数据全部复制过去,完全切断两个对象间的联系</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现浅拷贝,直接赋值</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">"Jack"</span>,<span class="attr">age</span>:<span class="number">19</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1</span><br><span class="line"><span class="built_in">console</span>.log(obj1 === obj2) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现深拷贝</span></span><br><span class="line"><span class="comment">//方法一:声明一个空对象,通过遍历,一个一个的将值赋值给空对象</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">"Jack"</span>,<span class="attr">age</span>:<span class="number">10</span>,<span class="attr">gender</span>:<span class="string">'f'</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj1)&#123;</span><br><span class="line">   obj2[key] = obj1[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj1 === obj2) <span class="comment">//false</span></span><br><span class="line"><span class="comment">//方法二:使用JSON.parse 和 JSON.stringify</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">"Jack"</span>,<span class="attr">name</span>:<span class="number">10</span>,<span class="attr">gender</span>:<span class="string">'f'</span>&#125;</span><br><span class="line"><span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(obj1)</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">JSON</span>.parse(str)</span><br><span class="line"><span class="built_in">console</span>.log(obj1 === obj2) <span class="comment">//false</span></span><br><span class="line"><span class="comment">// 方法三:使用es6的扩展运算符</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">'Jack'</span>,<span class="attr">age</span>:<span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;...obj1&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj2 === obj1)	<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h2 id="7-开发方式的划分"><a href="#7-开发方式的划分" class="headerlink" title="7. 开发方式的划分"></a>7. 开发方式的划分</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">混合式开发(开发模式):渲染方式是服务器渲染,浏览器端做的事情比较简单,只需要接收数据渲染页面,服务器端做的事情就多了,服务器端接收到浏览器端发送的请求之后,需要处理逻辑,响应数据(包括页面的数据和页面的结构代码)</span><br><span class="line"></span><br><span class="line">前后端分离(开发模式):渲染方式是浏览器渲染,服务器端只需提供接口返回数据,浏览器端接收到数据之后需要对数据进行逻辑处理,渲染页面</span><br></pre></td></tr></table></figure>



<h1 id="关于promise"><a href="#关于promise" class="headerlink" title="关于promise"></a>关于promise</h1><h2 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h2><p>因为回调函数是异步的,每一层的回调函数都需要依赖上一层的回调执行完,所以就形成了层层嵌套的关系,最终形成了回调地狱.例如:定时器中再写定时器再写定时器,这就形成了回调地狱</p>
<p>解决方案:1.避免函数嵌套        2.模块化开发        3.使用promise解决</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">promise是异步编程的一种解决方案,从语法上说promise是一个对象,从它可以获得异步操作的消息</span><br><span class="line">promise的特点:</span><br><span class="line">	1.promise一旦声明,就会立即执行一次里面的代码</span><br><span class="line">	2.自己身上有resolve,reject,all,race方法</span><br><span class="line">		成功回调promise,失败回调reject</span><br><span class="line">		all方法代表把多个promise对象打包起来统一管理,只要大家都没错,就调用then方法,其中有一个错就调用catch</span><br><span class="line">		race方法代表把多个promise对象打包起来,需要大家都对,谁先完成,就拿到谁的结果</span><br><span class="line">	3.promise的三种状态:</span><br><span class="line">		pending(进行中):当promise实例化出来时状态就为pending</span><br><span class="line">		fulfiled(已成功):调用resolve就是已成功状态(就是说调用resolve,就把状态改为已成功fulfilled)</span><br><span class="line">		rejected(已失败):调用reject就是已失败状态(就是说调用reject就把状态改为已失败状态)</span><br><span class="line">	3.原型身上有then和catch方法</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用promise封装一个wx.request方法</span></span><br><span class="line"><span class="comment">//使用promise构造函数,实例化一个promise对象,并return</span></span><br><span class="line"><span class="comment">//成功调用resolve(),失败调用reject()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myrequest</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        wx.request(&#123;</span><br><span class="line">            url:options.url,</span><br><span class="line">            method:options.method,</span><br><span class="line">            data:options.data,</span><br><span class="line">            header:options.header,</span><br><span class="line">            success:<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">                resolve(res)</span><br><span class="line">            &#125;,</span><br><span class="line">            fail:<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//要调用resolve,必须通过promise对象.then方法,里面传入一个函数,才能调用resolve</span></span><br><span class="line"><span class="comment">//promise对象.then不是代表调用里面的代码,只是代表给resolve和reject赋值而已</span></span><br></pre></td></tr></table></figure>

<h1 id="js高级"><a href="#js高级" class="headerlink" title="js高级"></a>js高级</h1><h2 id="1-正则"><a href="#1-正则" class="headerlink" title="1. 正则"></a>1. 正则</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// method1.创建一个正则对象---通过对象的方法创建一个正则对象</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'男'</span>)	<span class="comment">//这个规则是你的内容里面必须包含'男'这个字</span></span><br><span class="line"><span class="comment">// 2.调用正则的text方法来判断是否符合规则,符合得到true,不符合得到false</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'高个子男生'</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str)) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// method2.用字面量的方法创建正则</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/男/</span>	<span class="comment">//两个斜杠中间的就是正则</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">'男孩'</span>)) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预定义类,在正则里规定的一些符号,用来表达对应的意思</span></span><br><span class="line">. : 判断内容是否有除了\r,\n以外的字符, 有就返回<span class="literal">true</span>,没有就返回<span class="literal">false</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="regexp">/./</span>.test(<span class="string">'哈哈哈'</span>))	<span class="comment">//true</span></span><br><span class="line">\d : 判断是否有数字,有就返回<span class="literal">true</span>,没有就返回<span class="literal">false</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="regexp">/\d/</span>.test(<span class="string">'abc1'</span>))	<span class="comment">//有数字1,返回true</span></span><br><span class="line">\D : 判断是否有非数字,有就返回<span class="literal">true</span>,否则返回<span class="literal">false</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="regexp">/\D/</span>.test(<span class="string">'abc1'</span>))	<span class="comment">//有非数字abc,返回true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类,你写什么就帮你匹配什么</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/d/</span>.test(<span class="number">1234</span>))	<span class="comment">//1234里面没有字母d,返回false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数: i 表示忽略大小写   g 表示全局匹配</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/a/</span>.test(<span class="string">'AAAA'</span>)) <span class="comment">//true	</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或 和 优先级,在正则里面,一个|就代表或,要么匹配左边,要么匹配右边</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/hello|world/</span>.test(<span class="string">'hello'</span>)) <span class="comment">//匹配到左边,得到true</span></span><br><span class="line"><span class="comment">// 小括号的优先级高</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/hell(o|w)/</span>.test(<span class="string">'helle'</span>))	<span class="comment">// 既不是hello也不是hellw,所以返回false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单类: [] 代表只要出现括号中的某一个都算匹配</span></span><br><span class="line">/[<span class="number">123</span>a]/i  <span class="comment">// 只要出现1或者2或者3或者a,并且不区分大小写,都算匹配</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[123a]/i</span>.test(<span class="string">'abc'</span>)) <span class="comment">//abc里面包含a,返回true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 负向类,不能有这些的</span></span><br><span class="line">[abc] 要么有a,要么有b,要么有c</span><br><span class="line">[^abc] 找到abc以外的字符</span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[^abc]/</span>.test(<span class="string">'ad'</span>)  <span class="comment">// 有除了abc以外的字符d,返回true</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">// 组合类,把多个组合在一起</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[a-z1-5]/</span>.test(<span class="string">'bc'</span>))	<span class="comment">// 有a-z中的bc,返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[a-z1-5]/</span>.test(<span class="number">7</span>))		<span class="comment">// 7 不在a-z,也不在1-5,所以返回false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 边界类,^是以什么开头,$是以什么结尾</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^a/</span>.test(<span class="string">'abc'</span>))	<span class="comment">// 以a开头,返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/z$/</span>.test(<span class="string">'suibianz'</span>))	<span class="comment">//以z结尾的,返回true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 严格匹配,/^suibian$/,中间必须是suibian,除此之外不能有别的了</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^suibian$/</span>.test(<span class="string">'suibian123'</span>))		<span class="comment">// 除了suibian之外还有123,所以返回false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 量词</span></span><br><span class="line"><span class="string">"*"</span> 重复<span class="number">0</span>次 或者 多次 </span><br><span class="line"><span class="string">"+"</span> 重复<span class="number">1</span>次 或者 多次</span><br><span class="line"><span class="string">"?"</span> 重复<span class="number">0</span>次 或者 <span class="number">1</span>次</span><br><span class="line">&#123;n&#125; 必须匹配n次, &#123;<span class="number">5</span>&#125;:必须匹配<span class="number">5</span>次</span><br><span class="line">&#123;n,&#125; 重复n次或者更多</span><br><span class="line">&#123;n,m&#125; 重复至少n次,最多m次</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 正则 匹配 ip</span></span><br><span class="line"> 思路:前三位匹配三次,最后一个数字匹配一次</span><br><span class="line"> ((<span class="number">1</span>[<span class="number">0</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]\.)|(<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>][<span class="number">0</span><span class="number">-9</span>]\.)|(<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]\.)|([<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]\.)|([<span class="number">0</span><span class="number">-9</span>]\.))&#123;<span class="number">3</span>&#125;(<span class="number">1</span>[<span class="number">0</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>])|(<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>][<span class="number">0</span><span class="number">-9</span>])|(<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>])|([<span class="number">1</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>])|([<span class="number">0</span><span class="number">-9</span>]))</span><br></pre></td></tr></table></figure>

<h2 id="2-数组的方法"><a href="#2-数组的方法" class="headerlink" title="2.数组的方法"></a>2.数组的方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.reduce方法接收一个函数作为累加器,数组中的每个值从左到右开始累加</span></span><br><span class="line">arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">previousvalue,currentvalue,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// previousvalue:开始相加时的初始值</span></span><br><span class="line">    <span class="comment">// currentvalue:数组中当前被处理的元素</span></span><br><span class="line">    <span class="comment">// index:当前元素在数组中的索引</span></span><br><span class="line">    <span class="comment">// array:调用reduce的数组</span></span><br><span class="line">    <span class="comment">// initialvalue:相加时的初始值</span></span><br><span class="line">&#125;,initialvalue)</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.reduce(<span class="function">(<span class="params">x,y</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">&#125;)</span><br><span class="line">consoel.log(res)	<span class="comment">//10-----1+2+3+4</span></span><br><span class="line"><span class="keyword">let</span> res2 = arr.reduce(<span class="function">(<span class="params">x,y</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">&#125;,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(res2)	<span class="comment">//15-----5+1+2+3+4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. forEach()遍历数组的每一项,没有返回值,无论怎样,返回的都是undefined,不会通过return 或者 break 跳出循环,也不会改变原数组------直接在里面做逻辑操作</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">var</span> newArr = []</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(item&gt;<span class="number">2</span>)&#123;</span><br><span class="line">		newArr.push(item)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newArr)	<span class="comment">// [3,4,6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. map()不改变元素组,会返回一个新数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> newArr = arr.map(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item*<span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newArr)	<span class="comment">// [2,4,6,8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. for in 遍历对象的每个键</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">"Jack"</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. for of 可以用来遍历字符串中的每个字符</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'hello world'</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> s <span class="keyword">of</span> str)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(s)	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果:每个字符 h e l l o   w o r l d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. for in 可以用来遍历数组的下标,for of 可以用来遍历数组的元素值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> index <span class="keyword">in</span> arr)&#123; <span class="built_in">console</span>.log(index) &#125;	<span class="comment">// 0 1 2 3 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> value <span class="keyword">of</span> arr)&#123; <span class="built_in">console</span>.log(value) &#125;	<span class="comment">// 1 2 3 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. some()  遍历数组的每一项,如果任何一项满足条件,则会返回true,不会改变原数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.some(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> item&gt;<span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res)	<span class="comment">// 有三个大于2的,返回true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. every()  遍历数组的每一项,如果每一项都满足条件,则会返回true,不会改变原数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.every(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> item&gt;<span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res)	<span class="comment">// 4 5 不满足条件,返回false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. filter()遍历数组的每一项,返回一个符合条件的数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.filter(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item&gt;<span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// [3,4,5] 过滤掉小于2的</span></span><br></pre></td></tr></table></figure>

<h2 id="3-递归实现1乘100"><a href="#3-递归实现1乘100" class="headerlink" title="3.递归实现1乘100"></a>3.递归实现1乘100</h2><h2 id="4-冒泡-九九乘法表-字符串去空格-fibo数列-数组去重"><a href="#4-冒泡-九九乘法表-字符串去空格-fibo数列-数组去重" class="headerlink" title="4.冒泡,    九九乘法表,    字符串去空格,    fibo数列,    数组去重"></a>4.冒泡,    九九乘法表,    字符串去空格,    fibo数列,    数组去重</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">9</span>,<span class="number">18</span>,<span class="number">2</span>,<span class="number">33</span>,<span class="number">23</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">var</span> len = arr.length</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;len-i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">var</span> temp = arr[j];</span><br><span class="line">        arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">        arr[j+<span class="number">1</span>] = temp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr)	<span class="comment">// [1, 2, 3, 4, 5, 9, 18, 23, 33]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 九九乘法表</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=i;j&lt;=<span class="number">9</span>;j++)&#123;</span><br><span class="line">        str = str+i+<span class="string">'*'</span>+j + <span class="string">'='</span> +i*j</span><br><span class="line">        str += <span class="string">'\t'</span></span><br><span class="line">    &#125;</span><br><span class="line">    str += <span class="string">'\n'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串去空格</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'hello world'</span></span><br><span class="line"><span class="keyword">var</span> newStr = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(str[i] != <span class="string">' '</span>)&#123;</span><br><span class="line">        newStr += str[i]</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fibo数列</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibo</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Fibo(n<span class="number">-2</span>)+Fibo(n<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> n=<span class="number">0</span>;n&lt;<span class="number">10</span>;n++) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(Fibo(n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">var</span> newArr = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(newArr.indexOf(arr[i]) === <span class="number">-1</span>)&#123;	<span class="comment">//indexOf() != -1; 说明存在</span></span><br><span class="line">        <span class="comment">// 如果newArr中没有这个元素,就把这个元素push到newArr数组中</span></span><br><span class="line">        newArr.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用set数组去重</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">var</span> newArr = <span class="keyword">new</span> <span class="built_in">Set</span>(arr)</span><br><span class="line">newArr = [...newArr]</span><br><span class="line"><span class="built_in">console</span>.log(newArr)		<span class="comment">// [1,2,3,4,6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组里面对象的去重</span></span><br><span class="line"><span class="keyword">var</span> arr = [&#123;</span><br><span class="line">   key: <span class="string">'01'</span>,</span><br><span class="line">   value: <span class="string">'乐乐'</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">   key: <span class="string">'02'</span>,</span><br><span class="line">   value: <span class="string">'博博'</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">   key: <span class="string">'03'</span>,</span><br><span class="line">   value: <span class="string">'淘淘'</span></span><br><span class="line">  &#125;,&#123;</span><br><span class="line">   key: <span class="string">'04'</span>,</span><br><span class="line">   value: <span class="string">'哈哈'</span></span><br><span class="line">  &#125;,&#123;</span><br><span class="line">   key: <span class="string">'01'</span>,</span><br><span class="line">   value: <span class="string">'乐乐'</span></span><br><span class="line">  &#125;];</span><br><span class="line">  <span class="comment">// 方法1：利用对象访问属性的方法，判断对象中是否存在key</span></span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(!obj[arr[i].key])&#123;</span><br><span class="line">     result.push(arr[i]);</span><br><span class="line">     obj[arr[i].key] = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>

<h2 id="5-为什么0-1-0-2-0-3"><a href="#5-为什么0-1-0-2-0-3" class="headerlink" title="5. 为什么0.1+0.2 != 0.3"></a>5. 为什么0.1+0.2 != 0.3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是js运算中精度缺失的问题</span><br><span class="line">在计算机中数字其实是以二进制形式存储的,因为计算机的存储空间是有限的,0.1转换成二进制时是无限循环的,所以0.1在计算机中只能存储一个近似值,0.2也是以近似值存储的,所以两个近似值相加,得到的也是一个近似值 	</span><br><span class="line">解决办法:(0.1*1000 + 0.2*1000 )&#x2F;1000 &#x3D;&#x3D;&#x3D; 0.3</span><br></pre></td></tr></table></figure>

<h1 id="小程序中的问题"><a href="#小程序中的问题" class="headerlink" title="小程序中的问题"></a>小程序中的问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">商品的搜索列表的问题:</span><br><span class="line">问题表现:</span><br><span class="line">	第一次进入搜索列表的时候, 可以正常的获取到搜索的数据</span><br><span class="line">	如果点击返回,再搜索其他商品进入搜索列表,会将上一次打开页面中的数据再次加载,不会更新数据,所以得不到正确的搜	   索结果</span><br><span class="line">原因:</span><br><span class="line">	因为第一次请求这个页面时,小程序会将页面缓存到页面栈中,将来再次请求这个属性时,不会再加载一次页面,只会从页面		栈中取出并渲染,所以数据不会更新</span><br><span class="line">解决方案:</span><br><span class="line">	当离开该页面时,将数据全部清空,在onUnload()中清空数据,onUnload:当页面被卸载时执行</span><br></pre></td></tr></table></figure>

<h2 id="2-wxss-和-css-的区别"><a href="#2-wxss-和-css-的区别" class="headerlink" title="2. wxss 和 css 的区别"></a>2. wxss 和 css 的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one: wxss中引入新的单位,rpx</span><br><span class="line">two: app.wxss是全局样式,page.wxss是局部样式(在css中不存在全局或局部)</span><br><span class="line">three: wxss只支持部分选择器(类选择器,id选择器,伪元素)</span><br></pre></td></tr></table></figure>

<h2 id="3-js的防抖和节流"><a href="#3-js的防抖和节流" class="headerlink" title="3. js的防抖和节流"></a>3. js的防抖和节流</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">在进行窗口的resize、scroll、输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce(防抖)和throttle(节流)的方式来减少调用频率，同时又不影响实际效果</span><br><span class="line"></span><br><span class="line">防抖：当持续触发事件时，不执行事件处理函数，但是当触发停止一段时间后才执行一次（这一段时间是自己设置的）</span><br><span class="line"></span><br><span class="line">节流：当持续触发事件时，保证一段时间内只调用一次事件处理函数，也就是说每隔一段时间执行一次</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jieliu</span>(<span class="params">fn,tm</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// fn是触发事件的事件处理函数,tm是你设置的时间段(一段时间内执行一次)</span></span><br><span class="line">    <span class="comment">// 设置这段时间的开始时间</span></span><br><span class="line">    <span class="keyword">let</span> beginTime = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//得到当前时间</span></span><br><span class="line">        <span class="keyword">let</span> nowTime = <span class="built_in">Date</span>.now()</span><br><span class="line">        <span class="comment">// 得到两个时间的时间差</span></span><br><span class="line">        <span class="keyword">let</span> space = nowTime - beginTime</span><br><span class="line">        <span class="comment">// 判断时间差是否大于tm,如果大于等于了则需要执行一次函数</span></span><br><span class="line">        <span class="keyword">if</span>(space &gt;= tm)&#123;</span><br><span class="line">            fn()	<span class="comment">// fn是要执行的事件处理函数,是传进来的</span></span><br><span class="line">            <span class="comment">//重新设置开始时间---因为事件处理函数已经执行过一次,就需要重新设置起始时间</span></span><br><span class="line">            beginTime = <span class="built_in">Date</span>.now()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给页面添加滚动事件</span></span><br><span class="line"><span class="built_in">window</span>.onscroll = jieliu(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'onscroll'</span>)	<span class="comment">//事件处理函数</span></span><br><span class="line">&#125;,<span class="number">500</span>)</span><br></pre></td></tr></table></figure>





<h1 id="react相关面试题"><a href="#react相关面试题" class="headerlink" title="react相关面试题"></a>react相关面试题</h1><p>###</p>
<h1 id="简历上写的知识点"><a href="#简历上写的知识点" class="headerlink" title="简历上写的知识点"></a>简历上写的知识点</h1><h2 id="2-使用媒体查询，less-rem，bootstrap"><a href="#2-使用媒体查询，less-rem，bootstrap" class="headerlink" title="2.使用媒体查询，less+rem，bootstrap"></a>2.使用媒体查询，less+rem，bootstrap</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">媒体查询:</span><br><span class="line">@media(min-width:992px) and (max-width:1200px)&#123;&#125;</span><br><span class="line"></span><br><span class="line">less+rem</span><br><span class="line">step1:导入rem.js文件,设置rem为屏幕的1/10</span><br><span class="line">step2:使用cssrem插件,帮我们计算rem,直接写px可以转换成rem</span><br><span class="line"></span><br><span class="line">bootstrap</span><br><span class="line">原理:使用媒体查询</span><br><span class="line">使用:</span><br><span class="line">	step1:先引入jQuery,因为bootstrap的所有javascript插件都依赖于jQuery</span><br><span class="line">	step2:下载安装bootstrap 并 引入</span><br><span class="line">常用的组件</span><br><span class="line">栅格系统:12列</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-ms-1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">表格:为任意的表格添加类table, <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"table"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">按钮:为<span class="tag">&lt;<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span>&gt;</span> 元素添加类btn, <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">警告框, 模态框等</span><br><span class="line"></span><br><span class="line">Bootstrap使用Grunt作为编译系统</span><br></pre></td></tr></table></figure>



<h2 id="6-第六条-会使用iscroll-echarts"><a href="#6-第六条-会使用iscroll-echarts" class="headerlink" title="6.第六条,会使用iscroll,echarts"></a>6.第六条,会使用iscroll,echarts</h2><p>会使用iscroll</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建iscroll,在data中定义一个myScroll,在mounted里面创建iscroll对象</span></span><br><span class="line"><span class="comment">//使用iscroll一定要有三层盒子(容器,内容容器,内容),给最大的盒子(容器)设置高度,内容超过容器之后,自动滚动</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.myScroll = <span class="keyword">new</span> IScroll(wraper)	<span class="comment">//wraper是需要设置滚动条的最大的盒子</span></span><br><span class="line"><span class="comment">//在updated里面调用iscroll的refresh方法,告诉iscrollDOM发生改变了,重新计算大盒子wraper的高度</span></span><br><span class="line"><span class="keyword">this</span>.myScroll.refresh()</span><br></pre></td></tr></table></figure>

<p>会使用echarts</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">step1:引入echarts</span><br><span class="line">step2:为Echarts准备一个具备宽高的DOM容器</span><br><span class="line">	&lt;div id&#x3D;&quot;main&quot; style&#x3D;&quot;width: 600px;height:400px;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">step3:在script标签中</span><br><span class="line">	基于准备好的dom容器,初始化echarts实例</span><br><span class="line">	var myChart &#x3D; echarts.init(document.getElementById(&#39;main&#39;))</span><br><span class="line">step4:制定图表的配置项和数据</span><br><span class="line">	var option &#x3D; &#123;&#125;</span><br><span class="line">step5:使用指定的配置项和数据显示图表</span><br><span class="line">myChart.setOption(option)</span><br></pre></td></tr></table></figure>

<p>使用echarts时遇到过的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">随着组件里echarts绘图的增多,页面操作越来越卡顿,图表数据较大时,会比较卡</span><br><span class="line">切换页面时,echarts图例是销毁了,但是echarts实例还在内存当中,在mounted()方法和destroy()方法之间加一个beforeDestroy()方法释放该页面的chart资源,clear()方法则是清空图例数据，减少内存,不影响图例的resize，而且能够释放内存，切换的时候就很顺畅了</span><br><span class="line">beforeDestroy () &#123;</span><br><span class="line">	this.chart.clear()</span><br><span class="line">&#125;</span><br><span class="line">或者,写一个loading,提示用户等待加载</span><br></pre></td></tr></table></figure>



<h2 id="7-熟悉es6新语法-了解node-js"><a href="#7-熟悉es6新语法-了解node-js" class="headerlink" title="7. 熟悉es6新语法,了解node.js"></a>7. 熟悉es6新语法,了解node.js</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">声明变量: let const</span><br><span class="line">箭头函数: ()&#x3D;&gt;&#123;&#125;</span><br><span class="line">对象的方法: </span><br><span class="line">	Object.keys() 获得对象中的所有键,一数组的形式返回</span><br><span class="line">    Object.values() 获得对象中的所有属性值,以数组的形式返回</span><br><span class="line">    Object.entries() 获得对象中的所有成员,以数组的形式返回,数组中的每一个元素又是对象的键值组成的数组</span><br><span class="line">字符串方法:</span><br><span class="line">	str.includes() 找到字符串中包含某个字符,找到返回true,找不到返回false</span><br><span class="line">数组的方法:</span><br><span class="line">	every()  遍历数组的每一项,如果每一项都满足条件,则会返回true,不会改变原数组</span><br><span class="line">  	some()  遍历数组的每一项,如果任何一项满足条件,则会返回true,不会改变原数组</span><br><span class="line">  	filter() 遍历数组中的每一项,返回一个符合条件的数组</span><br><span class="line">  	forEach() 遍历数组的每一项,没有返回值,无论怎样,返回的都是undefined,不会通过return或者 </span><br><span class="line">              break跳出循环,也不会改变元素组</span><br><span class="line">  	map()  不改变原数组,返回一个新数组</span><br><span class="line"></span><br><span class="line">set方法</span><br><span class="line">async 和 await</span><br><span class="line">Promise</span><br></pre></td></tr></table></figure>

<h2 id="8-熟悉mpvue框架开发小程序"><a href="#8-熟悉mpvue框架开发小程序" class="headerlink" title="8. 熟悉mpvue框架开发小程序"></a>8. 熟悉mpvue框架开发小程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">step1: 现在已有vue-cli2.0版本,不用再安装了</span><br><span class="line">step2: 创建mpvue项目: vue init mpvue&#x2F;mpvue-quickstart 项目名</span><br><span class="line">step3: 进入项目目录,下载第三方依赖包:npm i,将vue项目打包成小程序项目: npm run dev</span><br><span class="line"></span><br><span class="line">mpvue项目结构:</span><br><span class="line">	main.js ---&gt; 加载app.vue</span><br><span class="line">    app.vue ---&gt; 加载app.json</span><br><span class="line">    app.json 管理了所有的页面路径:  pages&#x2F;index&#x2F;main    pages--&gt;index--&gt;main.js--&gt;加载了index.vue</span><br></pre></td></tr></table></figure>

<h2 id="关于性能优化的"><a href="#关于性能优化的" class="headerlink" title="关于性能优化的"></a>关于性能优化的</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">问到性能优化的，就那几个，1.图片优化，小图可以考虑base64，精灵图 2.图片懒加载 3.防抖节流 4.cdn 5.懒加载 6.预渲染，其实是服务器先渲染，可以联想到，为什么我们要把请求放在created，我自己的理解是，先在服务器渲染！官方建议的是在mounted。。</span><br></pre></td></tr></table></figure>

<h1 id="关于页面性能优化和web安全问题"><a href="#关于页面性能优化和web安全问题" class="headerlink" title="关于页面性能优化和web安全问题"></a>关于页面性能优化和web安全问题</h1><h2 id="1-页面优化问题"><a href="#1-页面优化问题" class="headerlink" title="1. 页面优化问题"></a>1. 页面优化问题</h2><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javascript提供里垃圾回收机制,垃圾回收机制会定期找出那些不再使用的变量的内存,然后将其释放掉</span><br><span class="line">垃圾回收机制的两种方法:标记清除,引用计数</span><br><span class="line">标记清除:当变量进入环境时,例如,在一个函数中声明一个变量,就将这个变量标记为&#39;进入环境&#39;,从逻辑上讲,永远不能释放进入环境变量所占用的内存,因为执行流进入相应的环境,就可能会用到他们.而当变量离开环境时,则将其标记为&#39;离开环境&#39;...   垃圾回收机制在运行的时候会先给所有的变量都加上标记,然后去掉那些进入环境的变量,后面剩下的变量就被视为准备删除的变量,然后释放掉这些变量的内存.</span><br><span class="line">引用计数:如果一个变量的引用次数为0,那就表示这个变量不在用到了,因此可以将这块内存释放</span><br></pre></td></tr></table></figure>

<h3 id="缓存-和-预加载"><a href="#缓存-和-预加载" class="headerlink" title="缓存 和 预加载"></a>缓存 和 预加载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">缓存是把请求过的数据缓存起来,下次请求的时候直接加载缓存内容,提高响应速度</span><br><span class="line">预加载指的是提前把需要的内容加载完成,访问的时候可以提高响应效率,比如图片的预加载</span><br></pre></td></tr></table></figure>

<h3 id="从页面反面考虑性能优化问题"><a href="#从页面反面考虑性能优化问题" class="headerlink" title="从页面反面考虑性能优化问题"></a>从页面反面考虑性能优化问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.对于html,尽量使用语义化的标签,即使css还没加载完,让用户也能看懂页面结构</span><br><span class="line">2.精灵图和字体图标,图片比较小的时候将图片转换成base64编码格式,图片使用懒加载</span><br><span class="line">3.css样式用link引入,不用import引入</span><br><span class="line">4.将js文件合并,css文件合并,压缩</span><br><span class="line">5.利用缓存和预解析</span><br></pre></td></tr></table></figure>

<h3 id="从服务器端考虑性能优化问题"><a href="#从服务器端考虑性能优化问题" class="headerlink" title="从服务器端考虑性能优化问题"></a>从服务器端考虑性能优化问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.使用CDN加速,使用户从离自己最近的服务器下载文件</span><br><span class="line">2.减少cookie的大小,客户端请求静态资源的时候,减少cookie的反复传输对主域名的影响</span><br></pre></td></tr></table></figure>



<h2 id="2-web安全问题"><a href="#2-web安全问题" class="headerlink" title="2. web安全问题"></a>2. web安全问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xss攻击:</span><br><span class="line">1.反射型攻击 通过url地址栏 注入攻击代码来攻击(目前浏览器可以自动防御攻击,对攻击内容进行编码)</span><br><span class="line">2.存储型攻击 通过表单的方式,将攻击的代码写到表单中提交到数据库,最终这个数据会显示到页面,从而达到攻击页面</span><br><span class="line">阻止攻击的方法:将提交的内容,通过xss.js库进行转义之后再提交,里面的攻击代码就失效了,攻击代码就变成无效的字符串了</span><br><span class="line">比如:&lt;iframe&gt;内容&lt;&#x2F;iframe&gt;  可以把箭头转义   &lt;iframe&gt;内容&lt;&#x2F;iframe&gt;</span><br><span class="line"></span><br><span class="line">csrf攻击:</span><br><span class="line">攻击的原理:利用cookie自动携带的特性,伪造用户的身份进行攻击</span><br><span class="line">阻止攻击的方法:在提交的表单中加一个token的验证,页面就有token和cookie两层验证,攻击者只能通过cookie验证,不能通过token验证,这样就可以达到阻止攻击的目的</span><br></pre></td></tr></table></figure>



<h1 id="html5-和css3"><a href="#html5-和css3" class="headerlink" title="html5 和css3"></a>html5 和css3</h1><h2 id="html5"><a href="#html5" class="headerlink" title="html5"></a>html5</h2><h3 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽"></a>拖拽</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">跟拖拽有关的事件:</span><br><span class="line">1.ondragstart  拖拽开始事件</span><br><span class="line">2.ondrag	   拖拽中</span><br><span class="line">3.ondragend	   拖拽结束</span><br><span class="line"></span><br><span class="line">跟容器有关的事件:</span><br><span class="line">1.ondragenter	拖拽进入事件</span><br><span class="line">2.ondragleave	拖拽离开事件</span><br><span class="line">3.ondrop	    当有元素进来,并在我的范围内松手才会触发的事件</span><br><span class="line">4.ondragover	它主要是为了ondrop事件服务的,在ondragover里阻止事件默认行为,才能让ondrop得到触发</span><br></pre></td></tr></table></figure>

<h3 id="web相关"><a href="#web相关" class="headerlink" title="web相关"></a>web相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">web存储: localStorage	sessionStorage</span><br><span class="line">web sql: 使用客户端直接去连接数据库</span><br><span class="line">web 应用缓存 : 将网站中不经常改变的内容以文件方式进行缓存</span><br><span class="line">web worker : 在页面的后台部分执行js脚本,这些脚本不会影响页面的状态</span><br><span class="line">	step1:创建一个worker对象</span><br><span class="line">	step2:在worker对象中传入一个后台执行js脚本</span><br><span class="line">	step3:当后台js脚本中的内容发生改变时会触发事件 onmessage</span><br><span class="line">	step4:创建一个后台执行的js脚本,这个脚本中返回数据的方式通过postMessage(data)</span><br><span class="line">websocket:浏览器与服务器通信的一种新的方式</span><br><span class="line">	http:建立连接需经过三次握手</span><br><span class="line">	websocket 连接一旦建立,除非一方主动断开,否则会永久连接</span><br></pre></td></tr></table></figure>

<h1 id="面试过的公司"><a href="#面试过的公司" class="headerlink" title="面试过的公司"></a>面试过的公司</h1><h2 id="一-华为外包"><a href="#一-华为外包" class="headerlink" title="一.华为外包"></a>一.华为外包</h2><h3 id="1-下拉数据太大时-怎么解决"><a href="#1-下拉数据太大时-怎么解决" class="headerlink" title="1.下拉数据太大时,怎么解决"></a>1.下拉数据太大时,怎么解决</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">类似于分页的思想</span><br><span class="line">step1:监听滚动事件</span><br><span class="line">step2:向下滚动时往后加载数据</span><br><span class="line">	判断是向上滚动还是向下滚动:1.记录上一次的滚动位置	2:当前位置与上一次的滚动位置作比较</span><br><span class="line">step3:向上滚动时往前加载数据</span><br><span class="line">step4:数据有进有出</span><br></pre></td></tr></table></figure>



<h2 id="二-深圳市航天欧化科技有限责任公司"><a href="#二-深圳市航天欧化科技有限责任公司" class="headerlink" title="二.深圳市航天欧化科技有限责任公司"></a>二.深圳市航天欧化科技有限责任公司</h2><h2 id="三-深信服科技有限公司"><a href="#三-深信服科技有限公司" class="headerlink" title="三.深信服科技有限公司"></a>三.深信服科技有限公司</h2><h2 id="四-点筹网"><a href="#四-点筹网" class="headerlink" title="四. 点筹网"></a>四. 点筹网</h2><h3 id="1-css-权重问题"><a href="#1-css-权重问题" class="headerlink" title="1. css 权重问题"></a>1. css 权重问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!important &gt; 行内式 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通配符选择器 &gt; 继承选择器</span><br></pre></td></tr></table></figure>

<h3 id="2-伪类-和-伪元素-的区别-before-和-before-的区别"><a href="#2-伪类-和-伪元素-的区别-before-和-before-的区别" class="headerlink" title="2. 伪类 和 伪元素 的区别? ::before 和 :before 的区别"></a>2. 伪类 和 伪元素 的区别? ::before 和 :before 的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">伪类：伪类是弥补了常规css的选择器的不足，有些元素使用不同选择器不容易获取到，那就可以使用伪类来为这些元素添加样式，比如:hover,a标签的:link，:active，比如给某个li标签添加不同的样式，li:nth-child(2)&#123;&#125;，li:first-child</span><br><span class="line"></span><br><span class="line">伪元素：伪元素本质上是创建了一个有内容的虚拟容器，伪元素实际上是不存在于文档树中的，但是在页面上能看得见</span><br><span class="line">比如： &lt;div&gt;hello-world&lt;&#x2F;div&gt; 在这个元素前面加一句，后面加一句</span><br><span class="line">div::before &#123;</span><br><span class="line">	content:&#39;在div元素的最前面添加新内容&#39;</span><br><span class="line">&#125;</span><br><span class="line">div::after &#123;</span><br><span class="line">	content:&#39;在div元素的最后面添加新内容&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">:before 和 ::before 都是css的伪元素，作用一样</span><br><span class="line">:befor 是css2的写法</span><br><span class="line">::before 是css3的写法，出现在css3中是为了区分伪类选择器，如:hover</span><br><span class="line">:before的兼容性要比::before好，不过在H5开发中建议使用::before比较好</span><br></pre></td></tr></table></figure>

<h3 id="3-transition-和-transform-的区别"><a href="#3-transition-和-transform-的区别" class="headerlink" title="3. transition 和 transform 的区别"></a>3. transition 和 transform 的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">transition 是过渡动画，是一个简写属性，用于设置四个过渡属性</span><br><span class="line">		transition-property：过渡的属性</span><br><span class="line">		transition-duration：过渡的时间</span><br><span class="line">		transition-timing-function:运动曲线(linear线性,steps()分步骤动画)</span><br><span class="line">		transition-delay：过渡动画的延迟时间</span><br><span class="line">transform 是元素的2D&#x2F;3D转换，它的属性值：translate(x,y)，rotate()，scale()，skew()</span><br></pre></td></tr></table></figure>

<h3 id="4-forEach-、map、for-in、for-of、some、every-的区别"><a href="#4-forEach-、map、for-in、for-of、some、every-的区别" class="headerlink" title="4. forEach 、map、for in、for of、some、every 的区别"></a>4. forEach 、map、for in、for of、some、every 的区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. forEach()遍历数组的每一项,没有返回值,无论怎样,返回的都是undefined,不会通过return 或者 break 跳出循环,也不会改变原数组------直接在里面做逻辑操作</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">var</span> newArr = []</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(item&gt;<span class="number">2</span>)&#123;</span><br><span class="line">		newArr.push(item)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newArr)	<span class="comment">// [3,4,6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. map()不改变元素组,会返回一个新数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> newArr = arr.map(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item*<span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newArr)	<span class="comment">// [2,4,6,8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. for in 遍历对象的每个键</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">"Jack"</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. for of 可以用来遍历字符串中的每个字符</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'hello world'</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> s <span class="keyword">of</span> str)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(s)	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果:每个字符 h e l l o   w o r l d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. for in 可以用来遍历数组的下标,for of 可以用来遍历数组的元素值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> index <span class="keyword">in</span> arr)&#123; <span class="built_in">console</span>.log(index) &#125;	<span class="comment">// 0 1 2 3 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> value <span class="keyword">of</span> arr)&#123; <span class="built_in">console</span>.log(value) &#125;	<span class="comment">// 1 2 3 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. some()  遍历数组的每一项,如果任何一项满足条件,则会返回true,不会改变原数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.some(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> item&gt;<span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res)	<span class="comment">// 有三个大于2的,返回true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. every()  遍历数组的每一项,如果每一项都满足条件,则会返回true,不会改变原数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.every(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> item&gt;<span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res)	<span class="comment">// 4 5 不满足条件,返回false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. filter()遍历数组的每一项,返回一个符合条件的数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.filter(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item&gt;<span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// [3,4,5] 过滤掉小于2的</span></span><br></pre></td></tr></table></figure>

<h3 id="5-promise的方法"><a href="#5-promise的方法" class="headerlink" title="5 . promise的方法"></a>5 . promise的方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resolve()方法: 这个回调函数表示的是成功的回调</span><br><span class="line">reject()方法:  这个回调函数表示的是失败的回调</span><br><span class="line">.then()方法:的参数赋值给resolve和reject</span><br><span class="line">.catch() 是一个统一错误的回调函数,无论哪个then有错,都会调用<span class="keyword">catch</span></span><br><span class="line"><span class="comment">// Promise的all()方法,把多个promise对象打包起来统一管理,只要大家都没错,才会调用then(),只要有一个错误就会调用catch,all()接收一个数组作为参数,数组里面每一个元素都是一个promise对象</span></span><br><span class="line"><span class="keyword">let</span> pAll = <span class="built_in">Promise</span>.all([p1,p2,p3])</span><br><span class="line"><span class="comment">// Promise的race()方法,也是把多个对象打包起来统一管理,需要每一个都对,谁先完成(谁先改变赚状态),就拿到谁的结果</span></span><br><span class="line"><span class="keyword">let</span> pAll = <span class="built_in">Promise</span>.race([p1,p2,p3])</span><br></pre></td></tr></table></figure>

<h2 id="五-三牛犇"><a href="#五-三牛犇" class="headerlink" title="五. 三牛犇"></a>五. 三牛犇</h2><h2 id="六-深圳市电子商务安全证书管理有限公司"><a href="#六-深圳市电子商务安全证书管理有限公司" class="headerlink" title="六.深圳市电子商务安全证书管理有限公司"></a>六.深圳市电子商务安全证书管理有限公司</h2><h3 id="拖拽盒子"><a href="#拖拽盒子" class="headerlink" title="拖拽盒子"></a>拖拽盒子</h3><p>核心:拖拽结束后,计算当前鼠标的位置</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    强行拖拽,加一个行内属性,draggable="true"</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span> <span class="attr">draggable</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 找到元素</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>)</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 1.拖拽开始</span></span></span><br><span class="line"><span class="actionscript">        box.ondragstart = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'拖拽开始'</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="comment">// 2.拖拽中</span></span></span><br><span class="line"><span class="actionscript">        box.ondrag = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'拖拽中'</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="comment">// 3.拖拽结束</span></span></span><br><span class="line"><span class="actionscript">        box.ondragend = <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'拖拽结束'</span>)</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//获取鼠标的坐标</span></span></span><br><span class="line"><span class="actionscript">            box.style.left = e.pageX - box.offsetWidth + <span class="string">'px'</span></span></span><br><span class="line"><span class="actionscript">            box.style.top = e.pageY - box.offsetHeight + <span class="string">'px'</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="拖拽到容器"><a href="#拖拽到容器" class="headerlink" title="拖拽到容器"></a>拖拽到容器</h3><p>核心:1.ondragover–阻止事件默认行为    2.ondrop–拖拽进入到我的范围内,并在我的范围内松手,就把拖拽的盒子添加进来</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"small"</span> <span class="attr">draggable</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 找到需要拖拽的盒子</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> small = <span class="built_in">document</span>.querySelector(<span class="string">'.small'</span>)</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 找到容器盒子</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> right = <span class="built_in">document</span>.querySelector(<span class="string">'.right'</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    right.ondragover = <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 阻止事件默认行为 </span></span></span><br><span class="line">      e.preventDefault();</span><br><span class="line"><span class="actionscript">      <span class="comment">//它的默认行为就是不断的阻止有元素进来</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// ondrop:当有元素进来,并在我的范围内松手才触发的事件</span></span></span><br><span class="line"><span class="actionscript">    right.ondrop = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 谁进入到我的范围,并且在我的范围内松手,就把谁添加到我里面</span></span></span><br><span class="line">      right.appendChild(small)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="拖拽图片到容器"><a href="#拖拽图片到容器" class="headerlink" title="拖拽图片到容器"></a>拖拽图片到容器</h3><p>核心:用到ondrop,拖拽到我的范围,并在我的范围内松手才触发的事件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./头像01.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">draggable</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./头像02.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">draggable</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./头像03.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">draggable</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 找到所有的图片</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> imgs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'img'</span>)</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 找到右边的容器</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> right = <span class="built_in">document</span>.querySelector(<span class="string">'.right'</span>)</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 用来保存当前img</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> currentImg</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 给所有的img添加拖拽开始事件</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;imgs.length;i++)&#123;</span></span><br><span class="line"><span class="actionscript">      imgs[i].ondragstart = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 谁拖拽开始,当前图片就是谁</span></span></span><br><span class="line"><span class="actionscript">        currentImg = <span class="keyword">this</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="comment">// 为ondrop服务的</span></span></span><br><span class="line"><span class="actionscript">    right.ondragover = <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span></span><br><span class="line">      e.preventDefault();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="comment">// 拖拽到我的范围内,并在我的范围内松手触发的事件</span></span></span><br><span class="line"><span class="actionscript">    right.ondrop = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line">      right.appendChild(currentImg)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="拖拽文件到浏览器"><a href="#拖拽文件到浏览器" class="headerlink" title="拖拽文件到浏览器"></a>拖拽文件到浏览器</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> img = <span class="built_in">document</span>.querySelector(<span class="string">'img'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.ondragover = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line">      e.preventDefault();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.ondrop = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 浏览器默认会打开你拖进来的文件的行为</span></span></span><br><span class="line">      e.preventDefault()</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e.dataTransfer.files[<span class="number">0</span>]) <span class="comment">//拖进来的文件</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> url = URL.createObjectURL(e.dataTransfer.files[<span class="number">0</span>])	<span class="comment">//把图片文件转换成图片的临时路径</span></span></span><br><span class="line">      img.src = url</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>



 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="my-Post"
  class="article article-type-my"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/06/Post/"
    >Post</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/06/06/Post/" class="article-date">
  <time datetime="2020-06-06T15:38:09.000Z" itemprop="datePublished">2020-06-06</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
   
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-hello-world"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/06/hello-world/"
    >Hello World</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/06/06/hello-world/" class="article-date">
  <time datetime="2020-06-06T13:28:40.503Z" itemprop="datePublished">2020-06-06</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
  </article>
  

  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2020
        <i class="ri-heart-fill heart_icon"></i> Mayue
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Mayue"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://shenyu-vip.lofter.com" target="_blank" rel="noopener">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Subtitle -->

<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
    console.log(err)
  }
</script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>